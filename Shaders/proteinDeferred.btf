<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="proteinDeferred">
    
    <include file="common" />
    
    <namespace name="contour">
        <shader name="vertex">
            <snippet type="version">110</snippet>
            <snippet name="main" type="string">
            <!--
varying vec3 posES;
void main(void) {
    gl_Position = gl_ModelViewProjectionMatrix*gl_Vertex;
    gl_TexCoord[0] = gl_MultiTexCoord0;
    posES = gl_Normal;
}
            -->
            </snippet>
        </shader>
        <shader name="fragment">
            <snippet type="version">110</snippet>
            <snippet name="::common::lighting::simple" />
            <snippet type="string">
            <!--
// TODO Write 'real' depth to depth buffer

#extension GL_EXT_gpu_shader4 : enable

uniform sampler2D depthBuff;
uniform sampler2D colorBuff;
uniform sampler2D normalBuff;
uniform int renderMode;
uniform int conMode;
uniform float threshold;
uniform float scale;

uniform vec2 clip;
uniform vec2 winSize;

varying vec3 posES;

float sobel() {
    float a,b,c,d,e,f,g,h,x;
    a = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, 1), 0).r;
    b = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(0, 1), 0).r;
    c = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(1, 1), 0).r;
    d = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, 0), 0).r;
    e = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(1, 0), 0).r;
    f = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, -1), 0).r;
    g = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(0, -1), 0).r;
    h = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy)+ivec2(1, -1), 0).r;
    float sobelX = -a+c-2.0*d+2.0*e-f+h;
    float sobelY = -a-2.0*b-c+f+2.0*g+h;
    return sqrt(sobelX*sobelX+sobelY*sobelY);
}

vec3 sobelNormal() {
    vec3 a,b,c,d,e,f,g,h,x;
    a = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, 1), 0).rgb;
    b = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(0, 1), 0).rgb;
    c = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(1, 1), 0).rgb;
    d = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, 0), 0).rgb;
    e = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(1, 0), 0).rgb;
    f = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(-1, -1), 0).rgb;
    g = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(0, -1), 0).rgb;
    h = texelFetch2D(normalBuff, ivec2(gl_FragCoord.xy)+ivec2(1, -1), 0).rgb;
    vec3 sobelX = -a+c-2.0*d+2.0*e-f+h;
    vec3 sobelY = -a-2.0*b-c+f+2.0*g+h;
    return sqrt(sobelX*sobelX+sobelY*sobelY);
}

float getScaleFactor(float val) {
    float s = scale*0.1;
    float t = threshold;
    vec4 x = vec4(0.0, (t/4.0)*(1.0+2.0*s), t*0.5, 1.0);
    
    float p00 = 0.0;
    float p11 = (t/4.0)*(1.0-2.0*s);
    float p22 = t*0.5;
    float p33 = 1.0;
    
    // Use Neville-Aitken algorithm to interpolate
    
    float p01 = ((x[1]-val)*p00+(val-x[0])*p11)/(x[1]-x[0]);
    float p12 = ((x[2]-val)*p11+(val-x[1])*p22)/(x[2]-x[1]);
    float p23 = ((x[3]-val)*p22+(val-x[2])*p33)/(x[3]-x[2]);
    
    float p02 = ((x[2]-val)*p01+(val-x[0])*p12)/(x[2]-x[0]);
    float p13 = ((x[3]-val)*p12+(val-x[1])*p23)/(x[3]-x[1]);
    
    float p03 = ((x[3]-val)*p02+(val-x[0])*p13)/(x[3]-x[0]);

    return p03;
}

void main(void) {
    
    vec4 color  = texture2D(colorBuff, gl_TexCoord[0].st);
    
    vec4 contour;
    if(conMode == 0) { // Use depth map for contour
        float grad = clamp(sobel(), 0.0, 1.0);
        //if(grad > threshold*0.1) grad = 1.0;
        //else grad = 0.0;
        float val = grad*getScaleFactor(grad);
        contour = vec4(1.0-val, 1.0-val, 1.0-val, color.a);
    }
    else if(conMode == 1){ // Use normal map for contour
        vec3 gradNorm = sobelNormal();
        float max = max(gradNorm.x, max(gradNorm.y, gradNorm.z));
        if(max > 0.9) {
            contour = vec4(vec3(0.0, 0.0, 0.0), color.a);
        }
        else
            contour = vec4(vec3(1.0, 1.0, 1.0), color.a);
    }   
    
    // Contour + color
    if(renderMode == 0) { 
        gl_FragColor = color*contour;
    }
    // Contour
    else if(renderMode == 1) {
        gl_FragColor = contour;
    }
    // Depth
    else if(renderMode == 2) { 
        gl_FragColor = texelFetch2D(depthBuff, ivec2(gl_FragCoord.xy), 0);
    }
    // Normal
    else if(renderMode == 3) { 
        vec3 normal = normalize(texture2D(normalBuff, gl_TexCoord[0].st).xyz);
        gl_FragColor = vec4(normal, color.a);
    }
    // Color
    else if(renderMode == 4) { 
        gl_FragColor = color;
    }
}
            -->
            </snippet>
        </shader>
    </namespace>
    
</btf>
