<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="cartoontessellationnew">
    <include file="common"/>

    <shader name="vertex">
        <snippet type="version">130</snippet>
        <snippet name="common::defines"/>
        <snippet name="attributes" type="string">
<!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require
uniform vec4 viewAttr;

uniform float scaling;

uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;

// clipping plane attributes
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform int instanceOffset;

uniform mat4 MVinv;
uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

uniform vec4 inConsts1;
uniform sampler1D colTab;

out vec4 objPos;
out vec4 camPos;
out vec4 lightPos;
out float squarRad;
out float rad;
out vec4 vertColor;

#define CONSTRAD inConsts1.x
#define MIN_COLV inConsts1.y
#define MAX_COLV inConsts1.z
#define COLTAB_SIZE inConsts1.w
-->
        </snippet>
        <snippet name="MainParams" type="string">
<!--
void main(void) {
    float theColIdx;
    vec4 theColor;
    vec4 inPos;
-->
        </snippet>
        <!-- here comes the injected snippet -->
        <snippet name="MainRest" type="string">
<!--
    vertColor = theColor;
        
    rad *= scaling;
    squarRad = rad * rad;
-->        
        </snippet>
        <snippet name="posTrans" type="string">
<!--
    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = MVinv[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    lightPos = MVinv * gl_LightSource[0].position;
    
    gl_Position = objPos;
    gl_PointSize = 2.0;
}
-->
        </snippet>
    </shader>

    <shader name="tesscontrol">
      <snippet type="version">400</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

uniform int uOuter0 = 1;
uniform int uOuter1 = 16;

uniform int minInner = 2;
uniform int maxInner = 12;
uniform int minOuter = 2;
uniform int maxOuter = 12;

uniform float minDistance;
uniform float maxDistance;

uniform int instanceOffset;

layout( vertices = 4 ) out;

in vec4 camPos[];
out int id[];

struct CAlpha
{
    vec4 pos;
    vec3 dir;
    int type;
};

layout(std430, binding = 2) buffer shader_data {
    CAlpha atoms[];
};

void main() {
    gl_out[gl_InvocationID].gl_Position = atoms[gl_PrimitiveID + gl_InvocationID].pos;
    id[gl_InvocationID] = gl_PrimitiveID + gl_InvocationID;
    gl_TessLevelOuter[0] = float( uOuter0);
    gl_TessLevelOuter[1] = float( uOuter1);
    
    
}
-->
      </snippet>
    </shader>

    <shader name="tesseval">
      <snippet type="version">400</snippet>
      <snippet type="string">
        <!--
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require
        
layout(isolines, equal_spacing) in;

in int id[];
out vec4 color;

struct CAlpha
{
    vec4 pos;
    vec3 dir;
    int type;
};

layout(std430, binding = 2) buffer shader_data {
    CAlpha atoms[];
};

void main() {
    vec4 p0 = gl_in[0].gl_Position;
    vec4 p1 = gl_in[1].gl_Position;
    vec4 p2 = gl_in[2].gl_Position;
    vec4 p3 = gl_in[3].gl_Position;
   
    
    vec4 colors[4];
    
    for(int i = 0; i < 4; i++)
    {
        int myid = id[i];
        int mytype = atoms[myid].type;
        
        if(mytype == 1) // beta sheet
        {
            colors[i] = vec4(0, 0, 1, 1);
        }
        else if(mytype == 2) // alpha helix
        {
            colors[i] = vec4(1, 0, 0, 1);
        }
        else if(mytype == 3) // turn
        {
            colors[i] = vec4(0.7, 0.7, 0.7, 1);
        }
        else // unclassified
        {
            colors[i] = vec4(0.7, 0.7, 0.7, 1);
        }
    }
    
    float u = gl_TessCoord.x;
    
    // Catmull-Rom Spline
    //gl_Position = 0.5 *( (2.0 * p1) + (-p0 + p2) * u + ( 2.0 * p0 - 5 * p1 + 4 * p2 - p3) * u * u + (-p0 + 3 * p1- 3 * p2 + p3) * u*u*u);
    
    // Cubic B-Spline
    u += 3;
    float q = ( u - 1.0) / 3.0;
    vec4 d10 = p0 * ( 1.0 - q) + p1 * q;
    float q1 = ( u - 2.0) / 3.0;
    vec4 d11 =  p1 * ( 1.0 - q1) + p2 * q1;
    float q2 = ( u - 3.0) / 3.0; 
    vec4 d12 =  p2 * ( 1.0 - q2) + p3 * q2;
    
    float q3 = ( u - 2.0) / 2.0; 
    vec4 d20 = d10 * ( 1.0 - q3) + d11 * q3;
    float q4 = ( u - 3.0) / 2.0; 
    vec4 d21 = d11 * ( 1.0 - q4) + d12 * q4;
    
    float q5 = ( u - 3.0); 
    gl_Position =  d20 * ( 1.0 - q5) + d21 * q5;
    
    // interpolate colors, too
    vec4 c10 = colors[0] * (1.0 - q) + colors[1] * q;
    vec4 c11 = colors[1] * (1.0 - q1) + colors[2] * q1;
    vec4 c12 = colors[2] * (1.0 - q2) + colors[3] * q2;
    
    vec4 c20 = c10 * (1.0 - q3) + c11 * q3;
    vec4 c21 = c11 * (1.0 - q4) + c12 * q4;
    
    color = c20 * (1.0 - q5) + c21 * q5;
}
-->
      </snippet>
    </shader>

    <shader name="geometry">
      <snippet type="version">400</snippet>
      <snippet type="string">
        <!--
uniform mat4 MVP;

layout(lines) in;
layout(line_strip, max_vertices = 4) out;

in vec4 color[];
out vec4 mycol;

void main() {
  for(int i = 0; i < gl_in.length(); i++) {
    gl_Position = MVP * gl_in[i].gl_Position;
    mycol = color[i];
    EmitVertex();
  }
  EndPrimitive();
}
-->
      </snippet>
    </shader>

    <shader name="fragment">
        <snippet type="version">140</snippet>
        <snippet name="common::defines"/>
        <snippet name="common::lighting::simple"/>
        <snippet name="body1" type="string">
<!--
#extension GL_ARB_conservative_depth:require
layout (depth_greater) out float gl_FragDepth; // we think this is right
// this should be wrong //layout (depth_less) out float gl_FragDepth;
#extension GL_ARB_explicit_attrib_location : enable

uniform mat4 MVP;
uniform mat4 MVPinv;
uniform mat4 MVPtransp;

uniform vec4 viewAttr;

FLACH in vec4 objPos;
FLACH in vec4 camPos;
FLACH in vec4 lightPos;
FLACH in float squarRad;
FLACH in float rad;
FLACH in vec4 vertColor;

in vec4 mycol;

out layout(location = 0) vec4 outCol;

void main(void) {
    //outCol = vec4( 1.0, 0.75, 0.2, 1.0);
    outCol = mycol;
}
-->
</snippet>
    </shader>

</btf>
