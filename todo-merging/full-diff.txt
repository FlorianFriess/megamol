diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
new file mode 100644
index 000000000..6544616b3
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Aggr.glsl
@@ -0,0 +1,59 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    float att = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result = color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        att += (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y - valRange.x);
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, vec4(result.xyz, att));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
new file mode 100644
index 000000000..19d7c8fc1
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-DVR.glsl
@@ -0,0 +1,68 @@
+/* opacity threshold for integration */
+uniform float opacityThreshold;
+
+/* texture containing transfer function */
+uniform highp sampler1D tf_tx1D;
+
+/* texture containing a depth buffer */
+uniform highp sampler2D color_tx2D;
+uniform highp sampler2D depth_tx2D;
+uniform int use_depth_tx;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Get pixel texture coordinates and depth value at original position
+    vec2 pixel_tex_coords = vec2(pixel_coords.x / rt_resolution.x, pixel_coords.y / rt_resolution.y);
+    const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
+
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    while (t < tfar && result.w < opacityThreshold) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        if (use_depth_tx != 0) {
+            // Compare depth values and decide to abort
+            const float depth = calculate_depth(pos);
+
+            if (depth > input_depth) {
+                const vec4 color = texture(color_tx2D, pixel_tex_coords);
+
+                result += (1.0f - result.w) * color;
+
+                break;
+            }
+        }
+
+        // Get sample
+        vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x) / (valRange.y-valRange.x));
+
+        // Calculate lighting
+        if (use_lighting) {
+            vol_sample.xyz = phong(vol_sample.xyz, calculate_normal(texCoords), -ray.d, light - pos);
+        }
+
+        // Opacity correction.
+        vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
+        vol_sample.xyz *= vol_sample.w;
+
+        result += (1.0f - result.w) * vol_sample;
+
+        t += rayStep;
+    }
+
+    // Write results
+    result = result.w * result + background * (1.0f - result.w);
+
+    imageStore(render_target_tx2D, pixel_coords, result);
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
new file mode 100644
index 000000000..9394f3e9c
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Functions.glsl
@@ -0,0 +1,89 @@
+struct Ray {
+    vec3 o;
+    vec3 d;
+};
+
+Ray generateRay(ivec2 pixel_coords) {
+    Ray ray;
+
+    // Transform pixel to clip coordinates
+    vec2 clip_space_pixel_coords =
+        vec2((pixel_coords.x / rt_resolution.x) * 2.0f - 1.0f, (pixel_coords.y / rt_resolution.y) * 2.0f - 1.0f);
+
+    // Unproject a point on the near plane and use as an origin
+    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
+    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
+
+    ray.o = unproj.xyz / unproj.w;
+
+    // Unproject a point at the same pixel, but further away from the near plane
+    // to compute a ray direction in world space
+    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
+
+    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
+
+    return ray;
+}
+
+bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
+    vec3 invR = vec3(1.0f) / r.d;
+    vec3 tbot = invR * (boxmin - r.o);
+    vec3 ttop = invR * (boxmax - r.o);
+
+    // Special case for a ray lying in a bounding plane.
+    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
+        ttop.x = -FLT_MAX;
+        tbot.x = FLT_MAX;
+    }
+    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
+        ttop.y = -FLT_MAX;
+        tbot.y = FLT_MAX;
+    }
+    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
+        ttop.z = -FLT_MAX;
+        tbot.z = FLT_MAX;
+    }
+
+    vec3 tmin = min(ttop, tbot);
+    vec3 tmax = max(ttop, tbot);
+
+    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
+    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
+
+    tnear = largest_tmin;
+    tfar = smallest_tmax;
+
+    return smallest_tmax > largest_tmin;
+}
+
+float wang_hash(uint seed) {
+    seed = (seed ^ 61) ^ (seed >> 16);
+    seed *= 9;
+    seed = seed ^ (seed >> 4);
+    seed *= 0x27d4eb2d;
+    seed = seed ^ (seed >> 15);
+
+    return float(seed) / 4294967296.0;
+}
+
+float calculate_depth(vec3 pos) {
+    vec4 clip_pos = proj_mx * view_mx * vec4(pos, 1.0f);
+
+    return ((clip_pos.z / clip_pos.w) + 1.0f) / 2.0f;
+}
+
+vec3 calculate_normal(vec3 texCoords) {
+    const float left = textureOffset(volume_tx3D, texCoords, ivec3(-1, 0, 0)).x;
+    const float right = textureOffset(volume_tx3D, texCoords, ivec3(1, 0, 0)).x;
+
+    const float bottom = textureOffset(volume_tx3D, texCoords, ivec3(0, -1, 0)).x;
+    const float top = textureOffset(volume_tx3D, texCoords, ivec3(0, 1, 0)).x;
+
+    const float front = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, -1)).x;
+    const float back = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, 1)).x;
+
+    return normalize(vec3(
+        (left - right) / halfVoxelSize.x,
+        (bottom - top) / halfVoxelSize.y,
+        (front - back) / halfVoxelSize.z));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
new file mode 100644
index 000000000..0e2ebba40
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Input.glsl
@@ -0,0 +1,35 @@
+#extension GL_ARB_compute_shader: enable
+#define FLT_MAX 3.402823466e+38
+#define FLT_MIN 1.175494351e-38
+#define PI      3.14159265
+
+/* matrices */
+uniform mat4 view_mx;
+uniform mat4 proj_mx;
+
+/* render targete resolution*/
+uniform vec2 rt_resolution;
+
+/* bounding box size */
+uniform vec3 boxMin;
+uniform vec3 boxMax;
+
+/* voxel size */
+uniform float voxelSize;
+uniform vec3 halfVoxelSize;
+
+/* sampling frequency */
+uniform float rayStepRatio;
+
+/* value range */
+uniform vec2 valRange;
+
+/* background color */
+uniform vec4 background;
+
+/* lighting */
+uniform bool use_lighting;
+uniform vec3 material_col;
+
+/* texture that houses the volume data */
+uniform highp sampler3D volume_tx3D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
new file mode 100644
index 000000000..108eae488
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Iso.glsl
@@ -0,0 +1,82 @@
+/* isovalue used for isosurface reconstruction */
+uniform float isoValue;
+
+/* opacity */
+uniform float opacity;
+
+/* output normal */
+layout(rgba32f, binding = 1) writeonly uniform highp image2D normal_target_tx2D;
+
+/* output depth */
+layout(r32f, binding = 2) writeonly uniform highp image2D depth_target_tx2D;
+
+/* main function for computation */
+void compute(float t, const float tfar, const Ray ray, const float rayStep, const ivec2 pixel_coords) {
+    // Initialize results
+    vec4 result = vec4(0.0f);
+
+    // Initialize output depth and normal value
+    float depth = FLT_MAX;
+    vec3 normal = vec3(0.0f);
+
+    // Store value and position from previous step
+    vec3 old_pos = ray.o + t * ray.d;
+    float old_value = 0.0f;
+
+    while (t < tfar) {
+        vec3 pos = ray.o + t * ray.d;
+
+        // Compute volume tex coordinates in [0,1] range.
+        vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
+        texCoords *= 1.0 - 2.0 * halfVoxelSize;
+        texCoords += halfVoxelSize;
+
+        // Get volume sample
+        float vol_sample = texture(volume_tx3D, texCoords).x;
+
+        if (vol_sample > isoValue) {
+            // Compute relative position between sample positions
+            const vec3 direction = pos - old_pos;
+            const float distance = (isoValue - old_value) / (vol_sample - old_value);
+
+            const vec3 surface_pos = old_pos + distance * direction;
+
+            depth = calculate_depth(surface_pos);
+
+            // Compute normal
+            normal = calculate_normal(texCoords);
+
+            // Compute illumination from fixed light
+            if (use_lighting) {
+                result = vec4(phong(material_col, normal, -ray.d, light - surface_pos), opacity);
+            } else {
+                result = vec4(material_col, opacity);
+            }
+
+            break;
+        }
+
+        // Store value and position for new "previous" step
+        old_pos = pos;
+        old_value = vol_sample;
+
+        // Adaptive step size
+        if (vol_sample / isoValue < 0.5f) {
+            t += rayStep;
+        } else {
+            t += rayStep * (1.0f + (rayStep / 10.0f) - vol_sample / isoValue);
+        }
+    }
+
+    // Write results
+    imageStore(render_target_tx2D, pixel_coords, result);
+    imageStore(normal_target_tx2D, pixel_coords, vec4(normal, 1.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(depth));
+}
+
+/* function for storing default output values */
+void storeDefaults(const ivec2 pixel_coords) {
+    imageStore(render_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(normal_target_tx2D, pixel_coords, vec4(0.0f));
+    imageStore(depth_target_tx2D, pixel_coords, vec4(FLT_MAX));
+}
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
new file mode 100644
index 000000000..402e9f949
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute-Output.glsl
@@ -0,0 +1,2 @@
+/* output image */
+layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
new file mode 100644
index 000000000..1a380996d
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Compute.glsl
@@ -0,0 +1,31 @@
+/* main routine */
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main() {
+    // Get pixel coordinates
+    vec3 gID = gl_GlobalInvocationID.xyz;
+    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
+
+    ivec2 pixel_coords = ivec2(gID.xy);
+
+    // Generate ray
+    Ray ray = generateRay(pixel_coords);
+    float rayStep = voxelSize * rayStepRatio;
+    float rayOffset = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x)) * rayStep;
+
+    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
+    // but do not render if the box is completely behind the camera.
+    float tnear, tfar;
+
+    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
+        // Initialize ray start and randomly offset it to prevent ringing artifacts
+        float t = tnear >= 0.0f ? tnear : 0.0f;
+        t += rayOffset;
+
+        // Start computation by calling the function from the specialized shader
+        compute(t, tfar, ray, rayStep, pixel_coords);
+    } else {
+        // Store default values by calling the function from the specialized shader
+        storeDefaults(pixel_coords);
+    }
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
new file mode 100644
index 000000000..de953c336
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment-Aggr.glsl
@@ -0,0 +1,22 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+uniform sampler1D tf_tx1D;
+
+uniform vec2 valRange;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    vec4 vol_sample = texture(tf_tx1D, (frag_out.w - valRange.x) / (valRange.y - valRange.x));
+    frag_out = vec4(frag_out.xyz * (1.0f - vol_sample.w) + vol_sample.xyz * vol_sample.w, 1.0f);
+
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
new file mode 100644
index 000000000..7cde99f50
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Fragment.glsl
@@ -0,0 +1,16 @@
+uniform sampler2D src_tx2D;
+uniform sampler2D normal_tx2D;
+uniform sampler2D depth_tx2D;
+
+in vec2 uv_coord;
+
+layout (location = 0) out vec4 frag_out;
+layout (location = 1) out vec4 normal_out;
+
+void main()
+{
+    frag_out = texture(src_tx2D, uv_coord);
+    normal_out = texture(normal_tx2D, uv_coord);
+
+    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
new file mode 100644
index 000000000..946885b57
--- /dev/null
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer-Vertex.glsl
@@ -0,0 +1,17 @@
+out vec2 uv_coord;
+
+void main()
+{
+    const vec4 vertices[6] = vec4[6](
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0,  1.0, 0.0, 1.0),
+        vec4( 1.0,  1.0, 1.0, 1.0),
+        vec4(-1.0, -1.0, 0.0, 0.0),
+        vec4( 1.0, -1.0, 1.0, 0.0));
+
+    const vec4 vertex = vertices[gl_VertexID];
+
+    uv_coord = vertex.zw;
+    gl_Position =  vec4(vertex.xy, -1.0, 1.0);
+}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
index 101b27261..eae925923 100644
--- a/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
+++ b/plugins/mmstd_volume/Shaders/RaycastVolumeRenderer.btf
@@ -1,20 +1,48 @@
 <?xml version="1.0" encoding="utf-8"?>
 <btf type="MegaMolGLSLShader" version="1.0" namespace="RaycastVolumeRenderer">
-    <include file="common"/>
 
     <shader name="compute">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/raycast_volume_c.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-DVR.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Aggr.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
+    </shader>
+
+    <shader name="compute_iso">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Input.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Output.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Functions.glsl</snippet>
+        <snippet type="file">phong.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute-Iso.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Compute.glsl</snippet>
     </shader>
 
     <shader name="vert">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_v.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Vertex.glsl</snippet>
     </shader>
 
     <shader name="frag">
         <snippet type="version">430</snippet>
-        <snippet name="body" type="file">raycast_volume/render_to_framebuffer_f.glsl</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment.glsl</snippet>
+    </shader>
+
+    <shader name="frag_aggr">
+        <snippet type="version">430</snippet>
+        <snippet type="file">RaycastVolumeRenderer-Fragment-Aggr.glsl</snippet>
     </shader>
 
 </btf>
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
deleted file mode 100644
index ee82f5907..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/raycast_volume_c.glsl
+++ /dev/null
@@ -1,183 +0,0 @@
-#extension GL_ARB_compute_shader: enable
-#define FLT_MAX 3.402823466e+38
-#define FLT_MIN 1.175494351e-38
-
-/* matrix that transforms a set of coordinates from world space to volume texture space */
-uniform mat4 volume_model_mx;
-/* camera inverse view projection matrix */
-//uniform mat4 camera_inv_view_proj_mx;
-
-uniform mat4 view_mx;
-uniform mat4 proj_mx;
-
-/* render targete resolution*/
-uniform vec2 rt_resolution;
-/**/
-uniform vec3 boxMin;
-/**/
-uniform vec3 boxMax;
-/**/
-uniform float voxelSize;
-/**/
-uniform vec3 halfVoxelSize;
-uniform float rayStepRatio;
-/**/
-uniform float opacityThreshold;
-
-uniform vec2 valRange;
-
-/*	texture that houses the volume data */
-uniform highp sampler3D volume_tx3D;
-/* texture containing scene depth */
-uniform highp sampler2D depth_tx2D;
-/* texture containing transfer function */
-//uniform highp sampler2D transfer_function_tx2D;
-uniform highp sampler1D tf_tx1D;
-
-layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
-
-struct Ray {
-    vec3 o;
-    vec3 d;
-};
-
-bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
-    vec3 invR = vec3(1.0f) / r.d;
-    vec3 tbot = invR * (boxmin - r.o);
-    vec3 ttop = invR * (boxmax - r.o);
-
-    // Special case for a ray lying in a bounding plane.
-    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
-        ttop.x = -FLT_MAX;
-        tbot.x = FLT_MAX;
-    }
-    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
-        ttop.y = -FLT_MAX;
-        tbot.y = FLT_MAX;
-    }
-    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
-        ttop.z = -FLT_MAX;
-        tbot.z = FLT_MAX;
-    }
-
-    vec3 tmin = min(ttop, tbot);
-    vec3 tmax = max(ttop, tbot);
-
-    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
-    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));
-
-    tnear = largest_tmin;
-    tfar = smallest_tmax;
-
-    return smallest_tmax > largest_tmin;
-}
-
-/////////////////////////////// Random Number Generator
-float wang_hash(uint seed) {
-    seed = (seed ^ 61) ^ (seed >> 16);
-    seed *= 9;
-    seed = seed ^ (seed >> 4);
-    seed *= 0x27d4eb2d;
-    seed = seed ^ (seed >> 15);
-
-    return float(seed) / 4294967296.0;
-}
-/////////////////////////////// End - Random Number Generator
-
-layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
-
-void main() {
-    vec3 gID = gl_GlobalInvocationID.xyz;
-
-    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;
-
-    ivec2 pixel_coords = ivec2(gID.xy);
-
-    vec2 clip_space_pixel_coords =
-        vec2((gID.x / rt_resolution.x) * 2.0f - 1.0f, (gID.y / rt_resolution.y) * 2.0f - 1.0f);
-
-    Ray ray;
-    // Unproject a point on the near plane and use as an origin.
-    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
-    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
-    ray.o = unproj.xyz / unproj.w;
-    // Unproject a point at the same pixel, but further away from the near plane
-    // to compute a ray direction in world space.
-    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
-    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);
-
-    // Just for safety.
-    // Box diagonal is sqrt(3) times longer.
-    float rayStep = voxelSize * rayStepRatio;
-    vec3 box_range = boxMax - boxMin;
-    float max_bbox_length = max(max(box_range.x, box_range.y), box_range.z);
-    //int maxSteps = int((1.0f / rayStep) * 1.74f * 2.0f * max_bbox_length); // todo
-
-    // Generate a random value in [0, 1] range.
-    // float randomTemp = sin(dot(vec2(pixel_coords.y * rt_resolution.x + pixel_coords.x), vec2(12.9898f, 78.233f))) *
-    // 43758.5453f; float random = abs(randomTemp - floor(randomTemp));
-    float random = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x));
-
-    float tnear, tfar;
-
-    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
-    // but do not render if the box is completely behind the camera.
-    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
-        float t = tnear >= 0.0f ? tnear : 0.0f;
-        t += random * rayStep; // Randomly offset the ray origin to prevent ringing artifacts
-        vec4 result = vec4(0.0f);
-        int steps = 0;
-
-        while (t < tfar && result.w < opacityThreshold /*&& steps < maxSteps*/) {
-            vec3 pos = ray.o + t * ray.d;
-            // Compute volume tex coordinates in [0,1] range.
-            vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
-            texCoords *= 1.0 - 2.0 * halfVoxelSize;
-            texCoords += halfVoxelSize;
-
-            //vec4 vol_sample = texture(transfer_function_tx2D, vec2(texture(volume_tx3D, texCoords).x, 1));
-            vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x)/valRange.y);
-            
-            // vec4 vol_sample = texture(volume_tx3D,texCoords);
-            // vol_sample.w = vol_sample.x;
-
-            // Opacity correction.
-            vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
-            // TF "Brightness". Make sure to not over-saturate the opacity.
-            // (Which will lead to color oversaturation.)
-            // vol_sample.w = min(vol_sample.w * cSeriesDesc.BrightnessPerSeries[series], 1.0f)
-            vol_sample.xyz *= vol_sample.w;
-            // if (useLighting)
-            //{
-            //    vec3 gradient = fetchGradientEstimate(cVolumesToRender.List[series],
-            //                                            cSeriesDesc.ComponentsPerSeries[series],
-            //                                            cTfs.List[series],
-            // texCoords,
-                //                                            rayStep * 8.0f);
-                //    float3 normal = normalize(-gradient);
-                //    float3 lightDir = normalize(cLightDesc.Pos - pos);
-                //    float lambert = max(0.0f, dot(normal, lightDir));
-                //    float3 lightColorContribution = cLightDesc.Color * cLightDesc.Intensity * lambert;
-                //    float3 surfaceColor = make_float3(mappedSample)
-                //    mappedSample += make_float4(surfaceColor * lightColorContribution, 0.0f);
-                //}
-
-                result += (1.0f - result.w) * vol_sample;
-
-            steps++;
-            t += rayStep;
-        }
-
-        // Blend with white background. (Helps to make the renderings look more consistent.)
-        // todo Is this correct? What if bg was transparent? The result would change with this formula.
-        // result = (result.w) * result + vec4(1.0f,0.0,0.0,0.0) * (1.0f - result.w);
-        // result.w = 1.0f;
-        imageStore(render_target_tx2D, pixel_coords, result);
-
-        // debug
-        // imageStore(render_target_tx2D,pixel_coords,vec4(1.0));
-    } else {
-        // Always write out to make sure that data from the previous frame is overwritten.
-        imageStore(render_target_tx2D, pixel_coords, vec4(0.0));
-    }
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
deleted file mode 100644
index 65a761c90..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_f.glsl
+++ /dev/null
@@ -1,10 +0,0 @@
-uniform sampler2D src_tx2D;
-
-in vec2 uv_coord;
-
-out vec4 frag_out;
-
-void main()
-{
-    frag_out = texture(src_tx2D,uv_coord);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl b/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
deleted file mode 100644
index e036f7b3a..000000000
--- a/plugins/mmstd_volume/Shaders/raycast_volume/render_to_framebuffer_v.glsl
+++ /dev/null
@@ -1,16 +0,0 @@
-out vec2 uv_coord;
-
-void main()
-{
-	const vec4 vertices[6] = vec4[6]( vec4( -1.0,-1.0,0.0,0.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,1.0,0.0,1.0 ),
-									vec4( 1.0,1.0,1.0,1.0 ),
-									vec4( -1.0,-1.0,0.0,0.0 ),
-                                	vec4( 1.0,-1.0,1.0,0.0 ) );
-
-	vec4 vertex = vertices[gl_VertexID];
-	
-	uv_coord = vertex.zw;
-	gl_Position =  vec4(vertex.xy, -1.0, 1.0);
-}
\ No newline at end of file
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
index 4386318fe..c3381bfe9 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.cpp
@@ -7,33 +7,120 @@
 
 #include "RaycastVolumeRenderer.h"
 
-#include <array>
-
-#include "vislib/graphics/gl/ShaderSource.h"
+#include "linmath.h"
 
 #include "mmcore/CoreInstance.h"
 #include "mmcore/misc/VolumetricDataCall.h"
+#include "mmcore/param/BoolParam.h"
+#include "mmcore/param/ColorParam.h"
+#include "mmcore/param/EnumParam.h"
 #include "mmcore/param/FloatParam.h"
+#include "mmcore/utility/ScaledBoundingBoxes.h"
+#include "mmcore/view/AbstractRenderingView.h"
 #include "mmcore/view/CallGetTransferFunction.h"
+#include "mmcore/view/CallRender3D.h"
 
-#include "linmath.h"
+#include "vislib/graphics/gl/ShaderSource.h"
+
+#include "glowl/Texture.hpp"
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <algorithm>
+#include <array>
+#include <cmath>
+#include <limits>
+#include <memory>
+#include <vector>
+#include <iostream>
 
 using namespace megamol::stdplugin::volume;
 
 RaycastVolumeRenderer::RaycastVolumeRenderer()
     : Renderer3DModule()
+    , m_mode("mode", "Mode changing the behavior for the raycaster")
+    , m_ray_step_ratio_param("ray step ratio", "Adjust sampling rate")
+    , m_use_lighting_slot("lighting::use lighting", "Enable simple volumetric illumination")
+    , m_ka_slot("lighting::ka", "Ambient part for Phong lighting")
+    , m_kd_slot("lighting::kd", "Diffuse part for Phong lighting")
+    , m_ks_slot("lighting::ks", "Specular part for Phong lighting")
+    , m_shininess_slot("lighting::shininess", "Shininess for Phong lighting")
+    , m_ambient_color("lighting::ambient color", "Ambient color")
+    , m_specular_color("lighting::specular color", "Specular color")
+    , m_light_color("lighting::light color", "Light color")
+    , m_material_color("lighting::material color", "Material color")
+    , m_opacity_threshold("opacity threshold", "Opacity threshold for integrative rendering")
+    , m_iso_value("isovalue", "Isovalue for isosurface rendering")
+    , m_opacity("opacity", "Surface opacity for blending")
+    , paramOverride("override::enable", "Enable override of range")
+    , paramMinOverride("override::min", "Override the minimum value provided by the data set")
+    , paramMaxOverride("override::max", "Override the maximum value provided by the data set")
+    , m_renderer_callerSlot("Renderer", "Renderer for chaining")
     , m_volumetricData_callerSlot("getData", "Connects the volume renderer with a voluemtric data source")
-    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function")
-    , m_ray_step_ratio_param("ray step ratio", "") {
+    , m_transferFunction_callerSlot("getTranfserFunction", "Connects the volume renderer with a transfer function") {
+
+    this->m_renderer_callerSlot.SetCompatibleCall<megamol::core::view::CallRender3DDescription>();
+    this->MakeSlotAvailable(&this->m_renderer_callerSlot);
+
     this->m_volumetricData_callerSlot.SetCompatibleCall<megamol::core::misc::VolumetricDataCallDescription>();
     this->MakeSlotAvailable(&this->m_volumetricData_callerSlot);
 
     this->m_transferFunction_callerSlot.SetCompatibleCall<megamol::core::view::CallGetTransferFunctionDescription>();
     this->MakeSlotAvailable(&this->m_transferFunction_callerSlot);
 
-    auto* ep = new megamol::core::param::FloatParam(1.0);
-    this->m_ray_step_ratio_param << ep;
+    this->m_mode << new megamol::core::param::EnumParam(0);
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(0, "Integration");
+    this->m_mode.Param<megamol::core::param::EnumParam>()->SetTypePair(1, "Isosurface");
+    this->m_mode.Param<core::param::EnumParam>()->SetTypePair(2, "Aggregate");
+    this->MakeSlotAvailable(&this->m_mode);
+
+    this->m_ray_step_ratio_param << new megamol::core::param::FloatParam(1.0f);
     this->MakeSlotAvailable(&this->m_ray_step_ratio_param);
+
+    this->m_opacity_threshold << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity_threshold);
+
+    this->m_iso_value << new megamol::core::param::FloatParam(0.5f);
+    this->MakeSlotAvailable(&this->m_iso_value);
+
+    this->m_opacity << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->m_opacity);
+
+    this->m_use_lighting_slot << new core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->m_use_lighting_slot);
+
+    this->m_ka_slot << new core::param::FloatParam(0.1f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ka_slot);
+
+    this->m_kd_slot << new core::param::FloatParam(0.5f, 0.0f);
+    this->MakeSlotAvailable(&this->m_kd_slot);
+
+    this->m_ks_slot << new core::param::FloatParam(0.4f, 0.0f);
+    this->MakeSlotAvailable(&this->m_ks_slot);
+
+    this->m_shininess_slot << new core::param::FloatParam(10.0f, 0.0f);
+    this->MakeSlotAvailable(&this->m_shininess_slot);
+
+    this->m_ambient_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_ambient_color);
+
+    this->m_specular_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_specular_color);
+
+    this->m_light_color << new core::param::ColorParam(1.0f, 1.0f, 1.0f, 1.0f);
+    this->MakeSlotAvailable(&this->m_light_color);
+
+    this->m_material_color << new core::param::ColorParam(0.95f, 0.67f, 0.47f, 1.0f);
+    this->MakeSlotAvailable(&this->m_material_color);
+
+    this->paramOverride << new megamol::core::param::BoolParam(false);
+    this->MakeSlotAvailable(&this->paramOverride);
+
+    this->paramMinOverride << new megamol::core::param::FloatParam(0.0f);
+    this->MakeSlotAvailable(&this->paramMinOverride);
+
+    this->paramMaxOverride << new megamol::core::param::FloatParam(1.0f);
+    this->MakeSlotAvailable(&this->paramMaxOverride);
 }
 
 RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
@@ -41,27 +128,48 @@ RaycastVolumeRenderer::~RaycastVolumeRenderer() { this->Release(); }
 bool RaycastVolumeRenderer::create() {
     try {
         // create shader program
-        m_raycast_volume_compute_shdr = std::make_unique<vislib::graphics::gl::GLSLComputeShader>();
-        m_render_to_framebuffer_shdr = std::make_unique<vislib::graphics::gl::GLSLShader>();
-
         vislib::graphics::gl::ShaderSource compute_shader_src;
+        vislib::graphics::gl::ShaderSource compute_iso_shader_src;
+        vislib::graphics::gl::ShaderSource compute_aggr_shader_src;
         vislib::graphics::gl::ShaderSource vertex_shader_src;
         vislib::graphics::gl::ShaderSource fragment_shader_src;
+        vislib::graphics::gl::ShaderSource fragment_shader_aggr_src;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::compute", compute_shader_src))
             return false;
-        if (!m_raycast_volume_compute_shdr->Compile(compute_shader_src.Code(), compute_shader_src.Count()))
+        if (!m_raycast_volume_compute_shdr.Compile(compute_shader_src.Code(), compute_shader_src.Count()))
             return false;
-        if (!m_raycast_volume_compute_shdr->Link()) return false;
+        if (!m_raycast_volume_compute_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_iso", compute_iso_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Compile(compute_iso_shader_src.Code(), compute_iso_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_iso_shdr.Link()) return false;
+
+        if (!instance()->ShaderSourceFactory().MakeShaderSource(
+                "RaycastVolumeRenderer::compute_aggr", compute_aggr_shader_src))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Compile(compute_aggr_shader_src.Code(), compute_aggr_shader_src.Count()))
+            return false;
+        if (!m_raycast_volume_compute_aggr_shdr.Link()) return false;
 
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::vert", vertex_shader_src))
             return false;
         if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag", fragment_shader_src))
             return false;
-        if (!m_render_to_framebuffer_shdr->Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+        if (!instance()->ShaderSourceFactory().MakeShaderSource("RaycastVolumeRenderer::frag_aggr", fragment_shader_aggr_src))
+            return false;
+        if (!m_render_to_framebuffer_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
                 fragment_shader_src.Code(), fragment_shader_src.Count()))
             return false;
-        if (!m_render_to_framebuffer_shdr->Link()) return false;
+        if (!m_render_to_framebuffer_shdr.Link()) return false;
+
+        if (!m_render_to_framebuffer_aggr_shdr.Compile(vertex_shader_src.Code(), vertex_shader_src.Count(),
+                fragment_shader_aggr_src.Code(), fragment_shader_aggr_src.Count()))
+            return false;
+        if (!m_render_to_framebuffer_aggr_shdr.Link()) return false;
     } catch (vislib::graphics::gl::AbstractOpenGLShader::CompileException ce) {
         vislib::sys::Log::DefaultLog.WriteMsg(vislib::sys::Log::LEVEL_ERROR, "Unable to compile shader (@%s): %s\n",
             vislib::graphics::gl::AbstractOpenGLShader::CompileException::CompileActionName(ce.FailedAction()),
@@ -77,41 +185,16 @@ bool RaycastVolumeRenderer::create() {
         return false;
     }
 
-
-    // create render target texture
-    TextureLayout render_tgt_layout(GL_RGBA8, 1920, 1080, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
-            {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_render_target = std::make_unique<Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
-
-
-    // create empty volume texture
-    TextureLayout volume_layout(GL_R32F, 1, 1, 1, GL_RED, GL_FLOAT, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_volume_texture = std::make_unique<Texture3D>("raycast_volume_texture", volume_layout, nullptr);
-
-    // create empty transfer function texture
-    TextureLayout tf(GL_RGBA8, 1, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-        {});
-    m_transfer_function = std::make_unique<Texture2D>("raycast_volume_texture", tf, nullptr);
-
     return true;
 }
 
 void RaycastVolumeRenderer::release() {
-    m_raycast_volume_compute_shdr.reset(nullptr);
-    m_render_target.reset(nullptr);
 }
 
 bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     auto cr = dynamic_cast<core::view::CallRender3D*>(&call);
     auto cd = m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
 
     if (cr == nullptr) return false;
     if (cd == nullptr) return false;
@@ -126,8 +209,18 @@ bool RaycastVolumeRenderer::GetExtents(megamol::core::Call& call) {
     if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
 
     cr->SetTimeFramesCount(cd->FrameCount());
-    cr->AccessBoundingBoxes() = cd->GetBoundingBoxes();
-    cr->AccessBoundingBoxes().MakeScaledWorld(1.0f);
+
+    std::vector<core::BoundingBoxes> bbs{cd->GetBoundingBoxes()};
+
+    if (ci != nullptr) {
+        *ci = *cr;
+
+        if (!(*ci)(core::view::CallRender3D::FnGetExtents)) return false;
+
+        bbs.push_back(ci->GetBoundingBoxes());
+    }
+
+    cr->AccessBoundingBoxes() = core::utility::combineAndMagicScaleBoundingBoxes(bbs);
 
     return true;
 }
@@ -136,30 +229,108 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     megamol::core::view::CallRender3D* cr = dynamic_cast<core::view::CallRender3D*>(&call);
     if (cr == NULL) return false;
 
+    // Chain renderer
+    auto ci = m_renderer_callerSlot.CallAs<megamol::core::view::CallRender3D>();
+
+    if (ci != nullptr) {
+        ci->SetCameraParameters(cr->GetCameraParameters());
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            if (this->fbo.IsValid()) this->fbo.Release();
+            this->fbo.Create(ci->GetViewport().Width(), ci->GetViewport().Height(), GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE,
+                vislib::graphics::gl::FramebufferObject::ATTACHMENT_TEXTURE);
+            this->fbo.Enable();
+        }
+
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+        ci->SetTime(cr->Time());
+        if (!(*ci)(core::view::CallRender3D::FnRender)) return false;
+
+        if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+            this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+            this->fbo.Disable();
+        }
+    }
+
+    // create render target texture
+    if (this->m_render_target == nullptr || this->m_render_target->getWidth() != cr->GetViewport().Width() ||
+        this->m_render_target->getHeight() != cr->GetViewport().Height()) {
+
+        glowl::TextureLayout render_tgt_layout(GL_RGBA8, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_UNSIGNED_BYTE, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_render_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_render_target", render_tgt_layout, nullptr);
+
+        // create normal target texture
+        glowl::TextureLayout normal_tgt_layout(GL_RGBA32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1,
+            GL_RGBA, GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_normal_target =
+            std::make_unique<glowl::Texture2D>("raycast_volume_normal_target", normal_tgt_layout, nullptr);
+
+        // create depth target texture
+        glowl::TextureLayout depth_tgt_layout(GL_R32F, cr->GetViewport().Width(), cr->GetViewport().Height(), 1, GL_R,
+            GL_FLOAT, 1,
+            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
+                {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
+                {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
+            {});
+        m_depth_target = std::make_unique<glowl::Texture2D>("raycast_volume_depth_target", depth_tgt_layout, nullptr);
+    }
 
     // this is the apex of suck and must die
+    core::utility::glMagicScale scaling;
+    scaling.apply(cr->GetBoundingBoxes());
+
     GLfloat modelViewMatrix_column[16];
     glGetFloatv(GL_MODELVIEW_MATRIX, modelViewMatrix_column);
     GLfloat projMatrix_column[16];
     glGetFloatv(GL_PROJECTION_MATRIX, projMatrix_column);
+
+    std::array<float, 4> light = {0.0f, 0.0f, 1.0f, 1.0f};
+    glGetLightfv(GL_LIGHT0, GL_POSITION, light.data());
     // end suck
 
-    if (!updateVolumeData()) return false;
-    if (!updateTransferFunction()) return false;
+    if (!updateVolumeData(cr->Time())) return false;
 
     // enable raycast volume rendering program
-    m_raycast_volume_compute_shdr->Enable();
+    vislib::graphics::gl::GLSLComputeShader* compute_shdr;
+
+    // pick shader based on selected mode
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        if (!updateTransferFunction()) return false;
+
+        compute_shdr = &this->m_raycast_volume_compute_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        compute_shdr = &this->m_raycast_volume_compute_iso_shdr;
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (!updateTransferFunction()) return false;
+        compute_shdr = &this->m_raycast_volume_compute_aggr_shdr;
+    } else {
+        vislib::sys::Log::DefaultLog.WriteError("Unknown raycast mode.");
+        return false;
+    }
+
+    // setup
+    compute_shdr->Enable();
 
-    glUniformMatrix4fv(
-        m_raycast_volume_compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
-    glUniformMatrix4fv(m_raycast_volume_compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("view_mx"), 1, GL_FALSE, modelViewMatrix_column);
+    glUniformMatrix4fv(compute_shdr->ParameterLocation("proj_mx"), 1, GL_FALSE, projMatrix_column);
 
     vec2 rt_resolution;
     rt_resolution[0] = static_cast<float>(m_render_target->getWidth());
     rt_resolution[1] = static_cast<float>(m_render_target->getHeight());
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
+    glUniform2fv(compute_shdr->ParameterLocation("rt_resolution"), 1, rt_resolution);
 
-    // bbox sizes
     vec3 box_min;
     box_min[0] = m_volume_origin[0];
     box_min[1] = m_volume_origin[1];
@@ -168,88 +339,266 @@ bool RaycastVolumeRenderer::Render(megamol::core::Call& call) {
     box_max[0] = m_volume_origin[0] + m_volume_extents[0];
     box_max[1] = m_volume_origin[1] + m_volume_extents[1];
     box_max[2] = m_volume_origin[2] + m_volume_extents[2];
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMin"), 1, box_min);
-    glUniform3fv(m_raycast_volume_compute_shdr->ParameterLocation("boxMax"), 1, box_max);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMin"), 1, box_min);
+    glUniform3fv(compute_shdr->ParameterLocation("boxMax"), 1, box_max);
 
-    glUniform3f(m_raycast_volume_compute_shdr->ParameterLocation("halfVoxelSize"),
-        1.0f / (2.0f * (m_volume_resolution[0] - 1)), 1.0f / (2.0f * (m_volume_resolution[1] - 1)),
-        1.0f / (2.0f * (m_volume_resolution[2] - 1)));
+    glUniform3f(compute_shdr->ParameterLocation("halfVoxelSize"), 1.0f / (2.0f * (m_volume_resolution[0] - 1)),
+        1.0f / (2.0f * (m_volume_resolution[1] - 1)), 1.0f / (2.0f * (m_volume_resolution[2] - 1)));
     auto const maxResolution =
-        std::fmax(m_volume_resolution[0], std::fmax(m_volume_resolution[1], m_volume_resolution[2]));
-    auto const maxExtents = std::fmax(m_volume_extents[0], std::fmax(m_volume_extents[1], m_volume_extents[2]));
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
-    glUniform2fv(m_raycast_volume_compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("rayStepRatio"),
+        std::max(m_volume_resolution[0], std::max(m_volume_resolution[1], m_volume_resolution[2]));
+    auto const maxExtents = std::max(m_volume_extents[0], std::max(m_volume_extents[1], m_volume_extents[2]));
+    glUniform1f(compute_shdr->ParameterLocation("voxelSize"), maxExtents / (maxResolution - 1.0f));
+
+    // Force value range to user-defined range if requested.
+    if (this->paramOverride.Param<core::param::BoolParam>()->Value()) {
+        std::array<float, 2> overrideRange = {
+            this->paramMinOverride.Param<core::param::FloatParam>()->Value(),
+            this->paramMaxOverride.Param<core::param::FloatParam>()->Value()
+        };
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, overrideRange.data());
+
+    } else {
+        glUniform2fv(compute_shdr->ParameterLocation("valRange"), 1, valRange.data());
+    }
+
+    glUniform1f(compute_shdr->ParameterLocation("rayStepRatio"),
         this->m_ray_step_ratio_param.Param<core::param::FloatParam>()->Value());
-    glUniform1f(m_raycast_volume_compute_shdr->ParameterLocation("opacityThreshold"), 1.0);
+
+    glUniform1i(compute_shdr->ParameterLocation("use_lighting"),
+        this->m_use_lighting_slot.Param<core::param::BoolParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ka"),
+        this->m_ka_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("kd"),
+        this->m_kd_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("ks"),
+        this->m_ks_slot.Param<core::param::FloatParam>()->Value());
+    glUniform1f(compute_shdr->ParameterLocation("shininess"),
+        this->m_shininess_slot.Param<core::param::FloatParam>()->Value());
+    glUniform3fv(compute_shdr->ParameterLocation("light"), 1, light.data());
+    glUniform3fv(compute_shdr->ParameterLocation("ambient_col"), 1,
+        this->m_ambient_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("specular_col"), 1,
+        this->m_specular_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("light_col"), 1,
+        this->m_light_color.Param<core::param::ColorParam>()->Value().data());
+    glUniform3fv(compute_shdr->ParameterLocation("material_col"), 1,
+        this->m_material_color.Param<core::param::ColorParam>()->Value().data());
+
+    auto const arv = std::dynamic_pointer_cast<core::view::AbstractRenderingView const>(cr->PeekCallerSlot()->Parent());
+    std::array<float, 4> bkgndCol = {1.0f, 1.0f, 1.0f, 1.0f};
+    if (arv != nullptr) {
+        auto const ptr = arv->BkgndColour();
+        bkgndCol[0] = ptr[0];
+        bkgndCol[1] = ptr[1];
+        bkgndCol[2] = ptr[2];
+        bkgndCol[3] = 1.0f;
+    }
+    glUniform3fv(compute_shdr->ParameterLocation("background"), 1, bkgndCol.data());
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glUniform1f(compute_shdr->ParameterLocation("opacityThreshold"),
+            this->m_opacity_threshold.Param<core::param::FloatParam>()->Value());
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glUniform1f(
+            compute_shdr->ParameterLocation("isoValue"), this->m_iso_value.Param<core::param::FloatParam>()->Value());
+
+        glUniform1f(
+            compute_shdr->ParameterLocation("opacity"), this->m_opacity.Param<core::param::FloatParam>()->Value());
+    }
+
+    this->m_opacity_threshold.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 0);
+    this->m_iso_value.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
+    this->m_opacity.Parameter()->SetGUIVisible(this->m_mode.Param<core::param::EnumParam>()->Value() == 1);
 
     // bind volume texture
     glActiveTexture(GL_TEXTURE0);
     m_volume_texture->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("volume_tx3D"), 0);
+    glUniform1i(compute_shdr->ParameterLocation("volume_tx3D"), 0);
+
     // bind the transfer function
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_1D, tf_texture);
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("tf_tx1D"), 1);
-    /*m_transfer_function->bindTexture();
-    glUniform1i(m_raycast_volume_compute_shdr->ParameterLocation("transfer_function_tx2D"), 1);*/
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(compute_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (ci != nullptr) {
+            glActiveTexture(GL_TEXTURE2);
+            this->fbo.BindColourTexture();
+            glUniform1i(compute_shdr->ParameterLocation("color_tx2D"), 2);
+
+            glActiveTexture(GL_TEXTURE3);
+            this->fbo.BindDepthTexture();
+            glUniform1i(compute_shdr->ParameterLocation("depth_tx2D"), 3);
+
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 1);
+        } else {
+            glUniform1i(compute_shdr->ParameterLocation("use_depth_tx"), 0);
+        }
+    }
 
     // bind image texture
     m_render_target->bindImage(0, GL_WRITE_ONLY);
 
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        m_normal_target->bindImage(1, GL_WRITE_ONLY);
+        m_depth_target->bindImage(2, GL_WRITE_ONLY);
+    }
+
     // dispatch compute
-    m_raycast_volume_compute_shdr->Dispatch(
+    compute_shdr->Dispatch(
         static_cast<int>(std::ceil(rt_resolution[0] / 8.0f)), static_cast<int>(std::ceil(rt_resolution[1] / 8.0f)), 1);
 
-    m_raycast_volume_compute_shdr->Disable();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glBindImageTexture(2, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+        glBindImageTexture(1, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+    }
+
+    glBindImageTexture(0, 0, 0, GL_TRUE, 0, GL_WRITE_ONLY, GL_R8);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE3);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_3D, 0);
+
+    compute_shdr->Disable();
 
     glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
 
-    ////////
+    // read image back to determine min max
+    float rndr_min = std::numeric_limits<float>::max();
+    float rndr_max = std::numeric_limits<float>::lowest();
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE0);
+        m_render_target->bindTexture();
+        int width = 0;
+        int height = 0;
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
+        glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);
+        std::vector<float> tmp_data(width*height*4);
+        glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_FLOAT, tmp_data.data());
+
+        for (size_t idx = 0; idx < tmp_data.size() / 4; ++idx) {
+            auto const val = tmp_data[idx * 4 + 3];
+            if (val < rndr_min) rndr_min = val;
+            if (val > rndr_max) rndr_max = val;
+        }
+
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+
     // copy image to framebuffer
-    ///////
-    // TODO query gl state and reset to previous state?
-    glDisable(GL_DEPTH_TEST);
-    glEnable(GL_BLEND);
+    bool state_depth_test = glIsEnabled(GL_DEPTH_TEST);
+    bool state_blend = glIsEnabled(GL_BLEND);
+
+    GLint state_blend_src_rgb, state_blend_src_alpha, state_blend_dst_rgb, state_blend_dst_alpha;
+    glGetIntegerv(GL_BLEND_SRC_RGB, &state_blend_src_rgb);
+    glGetIntegerv(GL_BLEND_SRC_ALPHA, &state_blend_src_alpha);
+    glGetIntegerv(GL_BLEND_DST_RGB, &state_blend_dst_rgb);
+    glGetIntegerv(GL_BLEND_DST_ALPHA, &state_blend_dst_alpha);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 0 ||
+        this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        if (state_depth_test) glDisable(GL_DEPTH_TEST);
+    } else if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        if (!state_depth_test) glEnable(GL_DEPTH_TEST);
+    }
+
+    if (!state_blend) glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-    m_render_to_framebuffer_shdr->Enable();
+    auto fbo_shdr = &m_render_to_framebuffer_shdr;
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        fbo_shdr = &m_render_to_framebuffer_aggr_shdr;
+    }
+
+    fbo_shdr->Enable();
 
-    glActiveTexture(GL_TEXTURE1);
+    glActiveTexture(GL_TEXTURE0);
     m_render_target->bindTexture();
-    glUniform1i(m_render_to_framebuffer_shdr->ParameterLocation("src_tx2D"), 1);
+    glUniform1i(fbo_shdr->ParameterLocation("src_tx2D"), 0);
 
-    glDrawArrays(GL_TRIANGLES, 0, 6);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE1);
+        m_normal_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("normal_tx2D"), 1);
 
-    m_render_to_framebuffer_shdr->Disable();
+        glActiveTexture(GL_TEXTURE2);
+        m_depth_target->bindTexture();
+        glUniform1i(fbo_shdr->ParameterLocation("depth_tx2D"), 2);
 
+        GLenum buffers[] = {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT};
+        glDrawBuffers(2, buffers);
+    }
 
-    glUseProgram(0);
-    // glBindVertexArray(0);
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, tf_texture);
+        glUniform1i(fbo_shdr->ParameterLocation("tf_tx1D"), 1);
+
+        glUniform2f(fbo_shdr->ParameterLocation("valRange"), rndr_min, rndr_max);
+    }
+
+    glDrawArrays(GL_TRIANGLES, 0, 6);
+
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 1) {
+        glActiveTexture(GL_TEXTURE2);
+        glBindTexture(GL_TEXTURE_2D, 0);
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_2D, 0);
+    }
+    if (this->m_mode.Param<core::param::EnumParam>()->Value() == 2) {
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_1D, 0);
+    }
     glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_3D, 0);
-    glActiveTexture(GL_TEXTURE1);
     glBindTexture(GL_TEXTURE_2D, 0);
 
-    glBindBuffer(GL_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
-    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
-    glBindBuffer(GL_DRAW_INDIRECT_BUFFER, 0);
+    fbo_shdr->Disable();
 
-    glEnable(GL_DEPTH_TEST);
-    glDisable(GL_BLEND);
+    glBlendFuncSeparate(state_blend_src_rgb, state_blend_dst_rgb, state_blend_src_alpha, state_blend_dst_alpha);
+    if (!state_blend) glDisable(GL_BLEND);
+    if (state_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
 
     return true;
 }
 
-bool RaycastVolumeRenderer::updateVolumeData() {
+bool RaycastVolumeRenderer::updateVolumeData(const unsigned int frameID) {
     auto* cd = this->m_volumetricData_callerSlot.CallAs<megamol::core::misc::VolumetricDataCall>();
 
     if (cd == nullptr) return false;
 
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
-    if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    // Use the force
+    cd->SetFrameID(frameID, true);
+    do {
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_EXTENTS)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_METADATA)) return false;
+        if (!(*cd)(core::misc::VolumetricDataCall::IDX_GET_DATA)) return false;
+    } while (cd->FrameID() != frameID);
 
     // TODO check time and frame id or whatever else
     if (this->m_volume_datahash != cd->DataHash() || this->m_frame_id != cd->FrameID()) {
@@ -328,47 +677,24 @@ bool RaycastVolumeRenderer::updateVolumeData() {
 
     // TODO if/else data already on GPU
 
-    // debug using dummy-data
-    std::array<uint8_t, 8> debug_volume_data = {255, 0, 255, 0, 255, 255, 0, 0};
-    TextureLayout debug_volume_layout(GL_R8, 2, 2, 2, GL_RED, GL_UNSIGNED_BYTE, 1,
-        {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-            {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_NEAREST},
-            {GL_TEXTURE_MAG_FILTER, GL_NEAREST}},
-        {});
-
-    TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
+    glowl::TextureLayout volume_layout(internal_format, metadata->Resolution[0], metadata->Resolution[1],
         metadata->Resolution[2], format, type, 1,
         {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
             {GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_MIN_FILTER, GL_LINEAR},
             {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
         {});
 
-    m_volume_texture->reload(volume_layout, volumedata);
+    m_volume_texture = std::make_unique<glowl::Texture3D>("raycast_volume_texture", volume_layout, volumedata);
+
+    return true;
 }
 
 bool RaycastVolumeRenderer::updateTransferFunction() {
     core::view::CallGetTransferFunction* ct =
         this->m_transferFunction_callerSlot.CallAs<core::view::CallGetTransferFunction>();
-    //ct->SetRange(valRange);
+
     if (ct != NULL && ((*ct)())) {
         tf_texture = ct->OpenGLTexture();
-        /*float const* tf_tex = ct->GetTextureData();
-        unsigned int tf_size = ct->TextureSize();
-        auto tf_format = ct->OpenGLTextureFormat();
-
-        GLenum internal_format = tf_format == GL_RGB ? GL_RGB32F : GL_RGBA32F;
-        GLenum format = tf_format;
-        GLenum type = GL_FLOAT;
-
-        TextureLayout tf_layout(internal_format, tf_size, 1, 1, format, type, 1,
-            {{GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER}, {GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER},
-                {GL_TEXTURE_MIN_FILTER, GL_LINEAR}, {GL_TEXTURE_MAG_FILTER, GL_LINEAR}},
-            {});
-
-        m_transfer_function->reload(tf_layout, tf_tex);*/
-        // this->colorTransferGray(allColor, tf_tex, tex_size, processedColor, 3);
-    } else {
-        // this->colorTransferGray(allColor, NULL, 0, processedColor, 3);
     }
 
     return true;
diff --git a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
index 554bff170..b65e57765 100644
--- a/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
+++ b/plugins/mmstd_volume/src/RaycastVolumeRenderer.h
@@ -7,20 +7,23 @@
 
 #ifndef RAYCAST_VOLUME_RENDERER_H_INCLUDED
 #define RAYCAST_VOLUME_RENDERER_H_INCLUDED
-#if (defined(_MSC_VER) && (_MSC_VER > 1000))
-#    pragma once
-#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
-
-#include <array>
-
-#include "vislib/graphics/gl/GLSLComputeShader.h"
-#include "vislib/graphics/gl/OpenGLTexture2D.h"
+#pragma once
 
+#include "mmcore/Call.h"
 #include "mmcore/CallerSlot.h"
 #include "mmcore/param/ParamSlot.h"
-#include "mmcore/view/CallRender3D.h"
 #include "mmcore/view/Renderer3DModule.h"
 
+#include "vislib/graphics/gl/FramebufferObject.h"
+#include "vislib/graphics/gl/GLSLComputeShader.h"
+#include "vislib/graphics/gl/GLSLShader.h"
+
+#include "glowl/Texture2D.hpp"
+#include "glowl/Texture3D.hpp"
+
+#include <array>
+#include <limits>
+#include <memory>
 
 namespace megamol {
 namespace stdplugin {
@@ -95,355 +98,22 @@ protected:
      */
     bool Render(core::Call& call);
 
-    bool updateVolumeData();
+    bool updateVolumeData(const unsigned int frameID);
 
     bool updateTransferFunction();
 
 private:
-    /* OpenGL TextureLayout, Texture and Texture2D classes courtesy of glOwl by Michael Becher. */
-
-    struct TextureLayout {
-        TextureLayout() : width(0), internal_format(0), height(0), depth(0), format(0), type(0), levels(0) {}
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         */
-        TextureLayout(
-            GLint internal_format, int width, int height, int depth, GLenum format, GLenum type, GLsizei levels)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels) {}
-
-        /**
-         * \param internal_format Specifies the (sized) internal format of a texture (e.g. GL_RGBA32F)
-         * \param width Specifies the width of the texture in pixels.
-         * \param height Specifies the height of the texture in pixels. Will be ignored by Texture1D.
-         * \param depth Specifies the depth of the texture in pixels. Will be ignored by Texture1D and Texture2D.
-         * \param format Specifies the format of the texture (e.g. GL_RGBA)
-         * \param type Specifies the type of the texture (e.g. GL_FLOAT)
-         * \param int_parameters A list of integer texture parameters, each given by a pair of name and value (e.g.
-         * {{GL_TEXTURE_SPARSE_ARB,GL_TRUE},{...},...} \param int_parameters A list of float texture parameters, each
-         * given by a pair of name and value (e.g. {{GL_TEXTURE_MAX_ANISOTROPY_EX,4.0f},{...},...}
-         */
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>> const& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>> const& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-        TextureLayout(GLint internal_format, int width, int height, int depth, GLenum format, GLenum type,
-            GLsizei levels, std::vector<std::pair<GLenum, GLint>>&& int_parameters,
-            std::vector<std::pair<GLenum, GLfloat>>&& float_parameters)
-            : internal_format(internal_format)
-            , width(width)
-            , height(height)
-            , depth(depth)
-            , format(format)
-            , type(type)
-            , levels(levels)
-            , int_parameters(int_parameters)
-            , float_parameters(float_parameters) {}
-
-        GLint internal_format;
-        int width;
-        int height;
-        int depth;
-        GLenum format;
-        GLenum type;
-
-        GLsizei levels;
-
-        std::vector<std::pair<GLenum, GLint>> int_parameters;
-        std::vector<std::pair<GLenum, GLfloat>> float_parameters;
-    };
-
-    class Texture {
-    protected:
-        std::string m_id; ///< Identifier set by application to help identifying textures
-
-        GLuint m_name;             ///< OpenGL texture name given by glGenTextures
-        GLuint64 m_texture_handle; ///< Actual OpenGL texture handle (used for bindless)
-
-        GLenum m_internal_format;
-        GLenum m_format;
-        GLenum m_type;
-
-        GLsizei m_levels;
-
-        // TODO: Store texture parameters as well ?
-    public:
-        Texture(std::string id, GLint internal_format, GLenum format, GLenum type, GLsizei levels)
-            : m_id(id), m_internal_format(internal_format), m_format(format), m_type(type), m_levels(levels) {}
-        virtual ~Texture() { glDeleteTextures(1, &m_name); }
-        Texture(const Texture&) = delete;
-
-        virtual void bindTexture() const = 0;
-
-        void bindImage(GLuint location, GLenum access) const {
-            glBindImageTexture(location, m_name, 0, GL_TRUE, 0, access, m_internal_format);
-        }
-
-        void makeResident() { glMakeTextureHandleResidentARB(m_texture_handle); }
-        void makeNonResident() { glMakeTextureHandleNonResidentARB(m_texture_handle); }
-
-        virtual void updateMipmaps() = 0;
-
-        virtual TextureLayout getTextureLayout() const = 0;
-
-        std::string getId() const { return m_id; }
-
-        GLuint getName() const { return m_name; }
-        GLuint64 getTextureHandle() const { return m_texture_handle; }
-        GLuint64 getImageHandle(GLint level, GLboolean layered, GLint layer) const {
-            return glGetImageHandleARB(m_name, level, layered, layer, m_internal_format);
-        }
-
-        GLenum getInternalFormat() const { return m_internal_format; }
-        GLenum getFormat() const { return m_format; }
-        GLenum getType() const { return m_type; }
-    };
-
-    class Texture2D : public Texture {
-    public:
-        /**
-         * \brief Constructor that creates and loads a 2D texture.
-         *
-         * \param id A identifier given to the texture object
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        Texture2D(std::string id, TextureLayout const& layout, GLvoid* data, bool generateMipmap = false)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
-
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture (id: " << id << ") creation: " << err << std::endl;
-            }
-        }
-        Texture2D(const Texture2D&) = delete;
-        Texture2D(Texture2D&& other) = delete;
-        Texture2D& operator=(const Texture2D& rhs) = delete;
-        Texture2D& operator=(Texture2D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_2D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_2D, m_name);
-            glGenerateMipmap(GL_TEXTURE_2D);
-            glBindTexture(GL_TEXTURE_2D, 0);
-        }
-
-        /**
-         * \brief Reload the texture with any new format, type and size.
-         *
-         * \param layout A TextureLayout struct that specifies size, format and parameters for the texture
-         * \param data Pointer to the actual texture data.
-         * \param generateMipmap Specifies whether a mipmap will be created for the texture
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data, bool generateMipmap = false) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_2D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_iso_shdr;
+    vislib::graphics::gl::GLSLComputeShader m_raycast_volume_compute_aggr_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_shdr;
+    vislib::graphics::gl::GLSLShader m_render_to_framebuffer_aggr_shdr;
 
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_2D, pname_pvalue.first, pname_pvalue.second);
+    std::unique_ptr<glowl::Texture2D> m_render_target;
+    std::unique_ptr<glowl::Texture2D> m_normal_target;
+    std::unique_ptr<glowl::Texture2D> m_depth_target;
 
-            GLsizei levels = 1;
-
-            if (generateMipmap) levels = 1 + floor(log2(std::max(m_width, m_height)));
-
-            glTexStorage2D(GL_TEXTURE_2D, levels, m_internal_format, m_width, m_height);
-
-            if (data != nullptr) glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, m_format, m_type, data);
-
-            if (generateMipmap) glGenerateMipmap(GL_TEXTURE_2D);
-
-            glBindTexture(GL_TEXTURE_2D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during  (id: " << m_id << ") reload: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, 1, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() const { return m_width; }
-
-        unsigned int getHeight() const { return m_height; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-    };
-
-    class Texture3D : public Texture {
-    public:
-        Texture3D(std::string id, TextureLayout const& layout, GLvoid* data)
-            : Texture(id, layout.internal_format, layout.format, layout.type, layout.levels)
-            , m_width(layout.width)
-            , m_height(layout.height)
-            , m_depth(layout.depth) {
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            m_texture_handle = glGetTextureHandleARB(m_name);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during 3D texture (id:" << id << ") creation: " << err << std::endl;
-            }
-        }
-
-        Texture3D(const Texture3D&) = delete;
-        Texture3D(Texture3D&& other) = delete;
-        Texture3D& operator=(const Texture3D& rhs) = delete;
-        Texture3D& operator=(Texture3D&& rhs) = delete;
-
-        /**
-         * \brief Bind the texture.
-         */
-        void bindTexture() const { glBindTexture(GL_TEXTURE_3D, m_name); }
-
-        void updateMipmaps() {
-            glBindTexture(GL_TEXTURE_3D, m_name);
-            glGenerateMipmap(GL_TEXTURE_3D);
-            glBindTexture(GL_TEXTURE_3D, 0);
-        }
-
-        /**
-         * \brief Reload the texture.
-         * \param data Pointer to the new texture data.
-         */
-        void reload(TextureLayout const& layout, GLvoid const* data) {
-            m_width = layout.width;
-            m_height = layout.height;
-            m_depth = layout.depth;
-            m_internal_format = layout.internal_format;
-            m_format = layout.format;
-            m_type = layout.type;
-
-            glDeleteTextures(1, &m_name);
-
-            glGenTextures(1, &m_name);
-
-            glBindTexture(GL_TEXTURE_3D, m_name);
-
-            for (auto& pname_pvalue : layout.int_parameters)
-                glTexParameteri(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            for (auto& pname_pvalue : layout.float_parameters)
-                glTexParameterf(GL_TEXTURE_3D, pname_pvalue.first, pname_pvalue.second);
-
-            glTexStorage3D(GL_TEXTURE_3D, 1, m_internal_format, m_width, m_height, m_depth);
-
-            if (data != nullptr)
-                glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, m_width, m_height, m_depth, m_format, m_type, data);
-
-            glBindTexture(GL_TEXTURE_3D, 0);
-
-            GLenum err = glGetError();
-            if (err != GL_NO_ERROR) {
-                // "Do something cop!"
-                // std::cerr << "GL error during texture reloading: " << err << std::endl;
-            }
-        }
-
-        TextureLayout getTextureLayout() const {
-            return TextureLayout(m_internal_format, m_width, m_height, m_depth, m_format, m_type, m_levels);
-        }
-
-        unsigned int getWidth() { return m_width; }
-        unsigned int getHeight() { return m_height; }
-        unsigned int getDepth() { return m_depth; }
-
-    private:
-        unsigned int m_width;
-        unsigned int m_height;
-        unsigned int m_depth;
-    };
-
-    std::unique_ptr<vislib::graphics::gl::GLSLComputeShader> m_raycast_volume_compute_shdr;
-    std::unique_ptr<vislib::graphics::gl::GLSLShader> m_render_to_framebuffer_shdr;
-
-    std::unique_ptr<Texture2D> m_render_target;
-
-    std::unique_ptr<Texture3D> m_volume_texture;
-
-    std::unique_ptr<Texture2D> m_transfer_function;
+    std::unique_ptr<glowl::Texture3D> m_volume_texture;
 
     GLuint tf_texture;
 
@@ -454,13 +124,37 @@ private:
     float m_volume_extents[3];
     float m_volume_resolution[3];
 
+    /** Parameters for changing the behavior */
+    core::param::ParamSlot m_mode;
+
+    core::param::ParamSlot m_ray_step_ratio_param;
+    core::param::ParamSlot m_opacity_threshold;
+    core::param::ParamSlot m_iso_value;
+    core::param::ParamSlot m_opacity;
+
+    core::param::ParamSlot m_use_lighting_slot;
+    core::param::ParamSlot m_ka_slot;
+    core::param::ParamSlot m_kd_slot;
+    core::param::ParamSlot m_ks_slot;
+    core::param::ParamSlot m_shininess_slot;
+    core::param::ParamSlot m_ambient_color;
+    core::param::ParamSlot m_specular_color;
+    core::param::ParamSlot m_light_color;
+    core::param::ParamSlot m_material_color;
+
+    core::param::ParamSlot paramOverride;
+    core::param::ParamSlot paramMinOverride;
+    core::param::ParamSlot paramMaxOverride;
+
     /** caller slot */
+    megamol::core::CallerSlot m_renderer_callerSlot;
     megamol::core::CallerSlot m_volumetricData_callerSlot;
     megamol::core::CallerSlot m_transferFunction_callerSlot;
 
-    core::param::ParamSlot m_ray_step_ratio_param;
-
     std::array<float, 2> valRange;
+
+    /** FBO for chaining renderers */
+    vislib::graphics::gl::FramebufferObject fbo;
 };
 
 } // namespace volume
diff --git a/plugins/pbs/src/HeadnodeServer.cpp b/plugins/pbs/src/HeadnodeServer.cpp
index 422bdd3c0..6cc9b7701 100644
--- a/plugins/pbs/src/HeadnodeServer.cpp
+++ b/plugins/pbs/src/HeadnodeServer.cpp
@@ -15,6 +15,7 @@
 #include "mmcore/view/AbstractView.h"
 #include "mmcore/view/CallRenderView.h"
 #include "vislib/RawStorageSerialiser.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 
 megamol::pbs::HeadnodeServer::HeadnodeServer()
@@ -107,9 +108,11 @@ void megamol::pbs::HeadnodeServer::ParamUpdated(core::param::ParamSlot& slot) {
 bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
 
     AbstractNamedObject::const_ptr_type avp;
+    std::vector<char> const null_buf(MessageHeaderSize, 0);
     const core::view::AbstractView* av = nullptr;
     core::Call* call = nullptr;
     unsigned int csn = 0;
+    bool gotUpdate = false;
 
     av = nullptr;
     call = this->view_slot_.CallAs<core::Call>();
@@ -119,24 +122,59 @@ bool megamol::pbs::HeadnodeServer::get_cam_upd(std::vector<char>& msg) {
     }
     if (av == nullptr) return false;
 
-    csn = av->GetCameraSyncNumber();
-    if ((csn != syncnumber)) {
-        syncnumber = csn;
-        vislib::RawStorage mem;
-        vislib::RawStorageSerialiser serialiser(&mem);
-        av->SerialiseCamera(serialiser);
-
-        msg.resize(MessageHeaderSize + mem.GetSize());
-        msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
-        auto size = mem.GetSize();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
-
-        return true;
-    }
+ 
+    const auto fun = [this, &gotUpdate, &msg](Module* mod) {
+        const auto arv = dynamic_cast<core::view::AbstractRenderingView*>(mod);
+        if (!gotUpdate && arv != nullptr) {
+            const auto csn = arv->GetCameraSyncNumber();
+            if (this->syncnumbers.find(arv->FullName().PeekBuffer()) == this->syncnumbers.end() ||
+                csn != this->syncnumbers[arv->FullName().PeekBuffer()]) {
+
+                vislib::RawStorage mem(100);
+                vislib::RawStorageSerialiser serialiser(&mem);
+
+                arv->SerialiseCamera(serialiser);
+
+                const uint32_t viewlen = arv->FullName().Length() + 1;
+                msg.resize(MessageHeaderSize + mem.GetSize() + sizeof(uint32_t) + viewlen);
+                msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+                char* lenpos = msg.data() + 1 + MessageSizeSize;
+                *reinterpret_cast<uint32_t*>(lenpos) = viewlen;
+                char* namepos = lenpos + sizeof(uint32_t);
+                memcpy(namepos, arv->FullName().PeekBuffer(), viewlen);
+                auto size = mem.GetSize() + viewlen + sizeof(uint32_t);
+                std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                    msg.begin() + MessageTypeSize);
+                std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(),
+                    msg.begin() + MessageHeaderSize + sizeof(uint32_t) + viewlen);
+
+                gotUpdate = true;
+
+                this->syncnumbers[arv->FullName().PeekBuffer()] = csn;
+            }
+        }
+    };
+
+    this->GetCoreInstance()->EnumModulesNoLock(av->FullName().PeekBuffer(), fun);
+
+    //csn = av->GetCameraSyncNumber();
+    //if ((csn != syncnumber)) {
+    //    syncnumber = csn;
+    //    vislib::RawStorage mem;
+    //    vislib::RawStorageSerialiser serialiser(&mem);
+    //    av->SerialiseCamera(serialiser);
 
-    return false;
+    //    msg.resize(MessageHeaderSize + mem.GetSize());
+    //    msg[0] = static_cast<char>(MessageType::CAM_UPD_MSG);
+    //    auto size = mem.GetSize();
+    //    std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+    //        msg.begin() + MessageTypeSize);
+    //    std::copy(mem.AsAt<char>(0), mem.AsAt<char>(0) + mem.GetSize(), msg.begin() + MessageHeaderSize);
+
+    //    return true;
+    //}
+
+    return gotUpdate;
 }
 
 
@@ -179,20 +217,20 @@ void megamol::pbs::HeadnodeServer::do_communication() {
 
     // retrieve modulgraph
     if (this->deploy_project_slot_.Param<core::param::BoolParam>()->Value()) {
-    if (this->GetCoreInstance()->IsLuaProject()) {
-        auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
-        std::vector<char> msg(MessageHeaderSize + lua.size());
-        msg[0] = MessageType::PRJ_FILE_MSG;
-        auto size = lua.size();
-        std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
-            msg.begin() + MessageTypeSize);
-        std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
-        {
-            std::lock_guard<std::mutex> lock(send_buffer_guard_);
-            send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+        if (this->GetCoreInstance()->IsLuaProject()) {
+            auto const lua = std::string(this->GetCoreInstance()->GetMergedLuaProject());
+            std::vector<char> msg(MessageHeaderSize + lua.size());
+            msg[0] = MessageType::PRJ_FILE_MSG;
+            auto size = lua.size();
+            std::copy(reinterpret_cast<char*>(&size), reinterpret_cast<char*>(&size) + MessageSizeSize,
+                msg.begin() + MessageTypeSize);
+            std::copy(lua.begin(), lua.end(), msg.begin() + MessageHeaderSize);
+            {
+                std::lock_guard<std::mutex> lock(send_buffer_guard_);
+                send_buffer_.insert(send_buffer_.end(), msg.begin(), msg.end());
+            }
         }
     }
-    }
     try {
         while (run_threads_) {
             // Wait for message
@@ -215,7 +253,7 @@ void megamol::pbs::HeadnodeServer::do_communication() {
                 }
 
                 if (!send_buffer_.empty()) {
-		    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
+                    // vislib::sys::Log::DefaultLog.WriteInfo("HeadnodeServer: Sending parameter update.\n");
                     comm_fabric_.Send(send_buffer_, send_type::SEND);
                     send_buffer_.clear();
                     buffer_has_changed_.store(false);
diff --git a/plugins/pbs/src/HeadnodeServer.h b/plugins/pbs/src/HeadnodeServer.h
index 2a01e3668..b230cee66 100644
--- a/plugins/pbs/src/HeadnodeServer.h
+++ b/plugins/pbs/src/HeadnodeServer.h
@@ -12,6 +12,7 @@
 
 #include "DistributedProto.h"
 #include "FBOCommFabric.h"
+#include <map>
 
 namespace megamol {
 namespace pbs {
@@ -108,7 +109,8 @@ private:
 
     std::vector<char> send_buffer_;
 
-    unsigned int syncnumber = -1;
+    // unsigned int syncnumber = -1;
+    std::map<std::string, unsigned int> syncnumbers;
 
     std::thread comm_thread_;
 
diff --git a/plugins/pbs/src/RendernodeView.cpp b/plugins/pbs/src/RendernodeView.cpp
index 9d8114881..2d76bd6d8 100644
--- a/plugins/pbs/src/RendernodeView.cpp
+++ b/plugins/pbs/src/RendernodeView.cpp
@@ -14,6 +14,7 @@
 #include "vislib/RawStorageSerialiser.h"
 #include "vislib/sys/Log.h"
 #include "vislib/sys/SystemInformation.h"
+#include "mmcore/view/AbstractRenderingView.h"
 
 //#define RV_DEBUG_OUTPUT = 1
 
@@ -104,12 +105,23 @@ bool megamol::pbs::RendernodeView::process_msgs(Message_t const& msgs) {
                 msg.resize(size);
                 std::copy(ibegin + MessageHeaderSize, ibegin + MessageHeaderSize + size, msg.begin());
             }
-            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data()), msg.size());
-            auto view = this->getConnectedView();
-            if (view != nullptr) {
-                view->DeserialiseCamera(ser);
-            } else {
-                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. No view connected.");
+            uint32_t namelen = *reinterpret_cast<uint32_t*>(msg.data());
+            std::string viewname(msg.data() + sizeof(uint32_t));
+
+            vislib::RawStorageSerialiser ser(reinterpret_cast<unsigned char*>(msg.data() + sizeof(uint32_t) + namelen), msg.size() - namelen - sizeof(uint32_t));
+            //vislib::sys::Log::DefaultLog.WriteInfo("got info about view %s (len: %u), ser mem len = %u",
+            //    viewname.c_str(), namelen, ser.Storage()->GetSize());
+
+            bool foundview = false;
+            const auto fun = [&ser, &foundview](core::view::AbstractRenderingView* mod) {
+                mod->DeserialiseCamera(ser);
+                foundview = true;
+            };
+
+            this->GetCoreInstance()->FindModuleNoLock<core::view::AbstractRenderingView>(viewname, fun);
+           
+            if (!foundview) {
+                vislib::sys::Log::DefaultLog.WriteError("RendernodeView: Cannot update camera. Cannot find view %s.", viewname.c_str());
             }
         } break;
         case MessageType::HEAD_DISC_MSG:
