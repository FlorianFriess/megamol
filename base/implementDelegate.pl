#
# implementDelegate.pl
#
# Copyright (C) 2011 by VISUS (Universitaet Stuttgart).
# Alle Rechte vorbehalten.
#
use strict;


#
# Setup:
##############################################################################
my $outputFile = "include/vislib/Delegate.h";
my $paramCnt = 10;


#
# Output:
##############################################################################
open (my $out, ">$outputFile") || die "Cannot write output file \"$outputFile\"\n";


#
# Header
##############################################################################
print $out qq§/*
 * Delegate.h
 *
 * Copyright (C) 2006 - 2011 by Visualisierungsinstitut Universitaet Stuttgart. 
 * Alle Rechte vorbehalten.
 */

#ifndef VISLIB_DELEGATE_H_INCLUDED
#define VISLIB_DELEGATE_H_INCLUDED
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#include "vislib/IllegalStateException.h"
#include "vislib/memutils.h"


/*
 * This file is generated by 'implementDelegate.pl'
 */


namespace vislib {

§;


#
# full class
##############################################################################
print $out qq§
    /**
     * Class representing a single callback target, which can either be a
     * function (c or static member) or a member-object pair, both with an
     * optional context object (usually a pointer).
     *
     * The first template parameter specifies the return value.
     * The other template parameters define the parameter list of the
     * callback, while void is used to (implicitly) terminate the list.
     * The parameter list may only have a maximum of $paramCnt elements.
     */
    template<class Rv = void§;
my $funcParamList = "";
my $funcParamNameList = "";
my $funcCallParamList = "";
for (my $i = 1; $i <= $paramCnt; $i++) {
    print $out ", class P$i = void";
    if ($i ne 1) {
        $funcParamList .= ", ";
        $funcParamNameList .= ", ";
        $funcCallParamList .= ", ";
    }
    $funcParamList .= "P$i p$i";
    $funcParamNameList .= "P$i";
    $funcCallParamList .= "p$i";
}
print $out qq§>
    class Delegate {
    public:

        Delegate(void) : callee(NULL) {
        }

        Delegate(const Delegate& rhs) : callee(NULL) {
            (*this) = rhs;
        }

        Delegate(Rv (*funcPtr)($funcParamNameList))
                : callee(new FunctionCallee(funcPtr)) {
        }

        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)($funcParamNameList, CT1), CT2 ctxt)
                : callee(new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        }

        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)($funcParamNameList))
                : callee(new MethodCallee<C>(obj, methPtr)) {
        }

        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)($funcParamNameList, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        }

        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        void Set(Rv (*funcPtr)($funcParamNameList)) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionCallee(funcPtr);
        }

        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)($funcParamNameList, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }

        template<class C>
        void Set(C& obj, Rv (C::*methPtr)($funcParamNameList)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)($funcParamNameList, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        Rv operator()($funcParamList) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call($funcCallParamList);
        }

        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

    private:

        /**
         * base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call($funcParamList) = 0;

            /**
             * Clones this object
             *
             * return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Returns if this and rhs are equal
             *
             * param rhs The right hand side operand
             *
             * return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        class FunctionCallee : public AbstractCallee {
        public:
            FunctionCallee(Rv (*func)($funcParamNameList)) : AbstractCallee(), func(func) {
                // Intentionally empty
            }
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return this->func($funcCallParamList);
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }
        private:
            Rv (*func)($funcParamNameList);
        };

        template<class CT>
        class FunctionContextCallee : public AbstractCallee {
        public:
            FunctionContextCallee(Rv (*func)($funcParamNameList, CT), CT ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return this->func($funcCallParamList, this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee(this->func, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }
        private:
            Rv (*func)($funcParamNameList, CT);
            CT ctxt;
        };

        template<class C>
        class MethodCallee : public AbstractCallee {
        public:
            MethodCallee(C& obj, Rv (C::*meth)($funcParamNameList)) : AbstractCallee(), obj(obj), meth(meth) {
                // Intentionally empty
            }
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return (this->obj.*this->meth)($funcCallParamList);
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }
        private:
            C& obj;
            Rv (C::*meth)($funcParamNameList);
        };

        template<class C, class CT>
        class MethodContextCallee : public AbstractCallee {
        public:
            MethodContextCallee(C& obj, Rv (C::*meth)($funcParamNameList, CT), CT ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return (this->obj.*this->meth)($funcCallParamList, this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT>(this->obj, this->meth, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }
        private:
            C& obj;
            Rv (C::*meth)($funcParamNameList, CT);
            CT ctxt;
        };

        /** The callee target */
        AbstractCallee *callee;

    };

§;


#
# specialization classes for smaller parameter lists
##############################################################################
for (my $pcnt = $paramCnt - 1; $pcnt > 0; $pcnt--) {
print $out qq§
    /**
     * Template specialication for delegate functions with $pcnt parameters
     */
    template<class Rv§;
$funcParamList = "";
$funcParamNameList = "";
$funcCallParamList = "";
for (my $i = 1; $i <= $pcnt; $i++) {
    print $out ", class P$i";
    if ($i ne 1) {
        $funcParamList .= ", ";
        $funcParamNameList .= ", ";
        $funcCallParamList .= ", ";
    }
    $funcParamList .= "P$i p$i";
    $funcParamNameList .= "P$i";
    $funcCallParamList .= "p$i";
}
print $out qq§>
    class Delegate<Rv, $funcParamNameList§;
for (my $i = $pcnt; $i < $paramCnt; $i++) {
    print $out ", void";
}
print $out qq§> {
    public:

        Delegate(void) : callee(NULL) {
        }

        Delegate(const Delegate& rhs) : callee(NULL) {
            (*this) = rhs;
        }

        Delegate(Rv (*funcPtr)($funcParamNameList))
                : callee(new FunctionCallee(funcPtr)) {
        }

        template<class CT1, class CT2>
        Delegate(Rv (*funcPtr)($funcParamNameList, CT1), CT2 ctxt)
                : callee(new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        }

        template<class C>
        Delegate(C& obj, Rv (C::*methPtr)($funcParamNameList))
                : callee(new MethodCallee<C>(obj, methPtr)) {
        }

        template<class C, class CT1, class CT2>
        Delegate(C& obj, Rv (C::*methPtr)($funcParamNameList, CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        }

        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        void Set(Rv (*funcPtr)($funcParamNameList)) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionCallee(funcPtr);
        }

        template<class CT1, class CT2>
        void Set(Rv (*funcPtr)($funcParamNameList, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }

        template<class C>
        void Set(C& obj, Rv (C::*methPtr)($funcParamNameList)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        template<class C, class CT1, class CT2>
        void Set(C& obj, Rv (C::*methPtr)($funcParamNameList, CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        Rv operator()($funcParamList) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            return this->callee->Call($funcCallParamList);
        }

        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

    private:

        /**
         * base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual Rv Call($funcParamList) = 0;

            /**
             * Clones this object
             *
             * return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Returns if this and rhs are equal
             *
             * param rhs The right hand side operand
             *
             * return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        class FunctionCallee : public AbstractCallee {
        public:
            FunctionCallee(Rv (*func)($funcParamNameList)) : AbstractCallee(), func(func) {
                // Intentionally empty
            }
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return this->func($funcCallParamList);
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }
        private:
            Rv (*func)($funcParamNameList);
        };

        template<class CT>
        class FunctionContextCallee : public AbstractCallee {
        public:
            FunctionContextCallee(Rv (*func)($funcParamNameList, CT), CT ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return this->func($funcCallParamList, this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee(this->func, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }
        private:
            Rv (*func)($funcParamNameList, CT);
            CT ctxt;
        };

        template<class C>
        class MethodCallee : public AbstractCallee {
        public:
            MethodCallee(C& obj, Rv (C::*meth)($funcParamNameList)) : AbstractCallee(), obj(obj), meth(meth) {
                // Intentionally empty
            }
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return (this->obj.*this->meth)($funcCallParamList);
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }
        private:
            C& obj;
            Rv (C::*meth)($funcParamNameList);
        };

        template<class C, class CT>
        class MethodContextCallee : public AbstractCallee {
        public:
            MethodContextCallee(C& obj, Rv (C::*meth)($funcParamNameList, CT), CT ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual Rv Call($funcParamList) {
                return (this->obj.*this->meth)($funcCallParamList, this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT>(this->obj, this->meth, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }
        private:
            C& obj;
            Rv (C::*meth)($funcParamNameList, CT);
            CT ctxt;
        };

        /** The callee target */
        AbstractCallee *callee;

    };

§;
}

#
# specialization class for empty parameter lists
##############################################################################
print $out qq§
    /**
     * Template specialication for delegate functions without parameters
     */
    template<>
    class Delegate<§;
my $allIsVoid = "";
for (my $i = 1; $i <= $paramCnt; $i++) {
    if ($i ne 1) {
        $allIsVoid .= ", ";
    }
    $allIsVoid .= "void";
}
print $out qq§$allIsVoid> {
    public:

        Delegate(void) : callee(NULL) {
        }

        Delegate(const Delegate& rhs) : callee(NULL) {
            (*this) = rhs;
        }

        Delegate(void (*funcPtr)(void))
                : callee(new FunctionCallee(funcPtr)) {
        }

        template<class CT1, class CT2>
        Delegate(void (*funcPtr)(CT1), CT2 ctxt)
                : callee(new FunctionContextCallee<CT1>(funcPtr, ctxt)) {
        }

        template<class C>
        Delegate(C& obj, void (C::*methPtr)(void))
                : callee(new MethodCallee<C>(obj, methPtr)) {
        }

        template<class C, class CT1, class CT2>
        Delegate(C& obj, void (C::*methPtr)(CT1), CT2 ctxt)
                : callee(new MethodContextCallee<C, CT1>(obj, methPtr, ctxt)) {
        }

        ~Delegate(void) {
            SAFE_DELETE(this->callee);
        }

        inline bool IsTargetSet(void) const {
            return this->callee != NULL;
        }

        void Set(void (*funcPtr)(void)) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionCallee(funcPtr);
        }

        template<class CT1, class CT2>
        void Set(void (*funcPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new FunctionContextCallee<CT1>(funcPtr, ctxt);
        }

        template<class C>
        void Set(C& obj, void (C::*methPtr)(void)) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodCallee<C>(obj, methPtr);
        }

        template<class C, class CT1, class CT2>
        void Set(C& obj, void (C::*methPtr)(CT1), CT2 ctxt) {
            SAFE_DELETE(this->callee);
            this->callee = new MethodContextCallee<C, CT1>(obj, methPtr, ctxt);
        }

        void Unset(void) {
            SAFE_DELETE(this->callee);
        }

        void operator()(void) {
            if (this->callee == NULL) {
                throw vislib::IllegalStateException("Delegate target not set", __FILE__, __LINE__);
            }
            this->callee->Call();
        }

        bool operator==(const Delegate& rhs) const {
            if (this->callee == NULL) {
                return (rhs.callee == NULL);
            }
            return this->callee->Equals(*rhs.callee);
        }

        Delegate& operator=(const Delegate& rhs) {
            SAFE_DELETE(this->callee);
            if (rhs.callee != NULL) {
                this->callee = rhs.callee->Clone();
            }
            return *this;
        }

    private:

        /**
         * base class for callee implementations
         */
        class AbstractCallee {
        public:

            /** Ctor */
            AbstractCallee(void) {
                // intentionally empty
            }

            /** Dtor */
            virtual ~AbstractCallee(void) {
                // intentionally empty
            }

            /** Call */
            virtual void Call(void) = 0;

            /**
             * Clones this object
             *
             * return A clone
             */
            virtual AbstractCallee * Clone(void) = 0;

            /**
             * Returns if this and rhs are equal
             *
             * param rhs The right hand side operand
             *
             * return True if this and rhs are equal
             */
            virtual bool Equals(const AbstractCallee& rhs) = 0;

        };

        class FunctionCallee : public AbstractCallee {
        public:
            FunctionCallee(void (*func)(void)) : AbstractCallee(), func(func) {
                // Intentionally empty
            }
            virtual ~FunctionCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual void Call(void) {
                this->func();
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionCallee(this->func);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionCallee *r= dynamic_cast<const FunctionCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func);
            }
        private:
            void (*func)(void);
        };

        template<class CT>
        class FunctionContextCallee : public AbstractCallee {
        public:
            FunctionContextCallee(void (*func)(CT), CT ctxt) : AbstractCallee(), func(func), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~FunctionContextCallee(void) {
                this->func = NULL; // DO NOT DELETE
            }
            virtual void Call(void) {
                this->func(this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new FunctionContextCallee(this->func, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const FunctionContextCallee *r= dynamic_cast<const FunctionContextCallee*>(&rhs);
                return (r != NULL)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }
        private:
            void (*func)(CT);
            CT ctxt;
        };

        template<class C>
        class MethodCallee : public AbstractCallee {
        public:
            MethodCallee(C& obj, void (C::*meth)(void)) : AbstractCallee(), obj(obj), meth(meth) {
                // Intentionally empty
            }
            virtual ~MethodCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual void Call(void) {
                (this->obj.*this->meth)();
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodCallee<C>(this->obj, this->meth);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodCallee *r= dynamic_cast<const MethodCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }
        private:
            C& obj;
            void (C::*meth)(void);
        };

        template<class C, class CT>
        class MethodContextCallee : public AbstractCallee {
        public:
            MethodContextCallee(C& obj, void (C::*meth)(CT), CT ctxt) : AbstractCallee(), obj(obj), meth(meth), ctxt(ctxt) {
                // Intentionally empty
            }
            virtual ~MethodContextCallee(void) {
                this->meth = NULL; // DO NOT DELETE
            }
            virtual void Call(void) {
                (this->obj.*this->meth)(this->ctxt);
            }
            virtual AbstractCallee * Clone(void) {
                return new MethodContextCallee<C, CT>(this->obj, this->meth, this->ctxt);
            }
            virtual bool Equals(const AbstractCallee& rhs) {
                const MethodContextCallee *r= dynamic_cast<const MethodContextCallee*>(&rhs);
                return (r != NULL)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }
        private:
            C& obj;
            void (C::*meth)(CT);
            CT ctxt;
        };

        /** The callee target */
        AbstractCallee *callee;

    };
§;


#
# footer
##############################################################################
print $out qq§

} /* end namespace vislib */

#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* VISLIB_DELEGATE_H_INCLUDED */
§;


close ($out);
exit 0;
