<?xml version="1.0" encoding="utf-8"?>
<btf type="MegaMolGLSLShader" version="1.0" namespace="RaycastVolumeRenderer">
    <include file="common"/>

    <namespace name="common">
        <snippet name="input" type="string">
            <![CDATA[
#extension GL_ARB_compute_shader: enable
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define PI      3.14159265

/* matrices */
uniform mat4 view_mx;
uniform mat4 proj_mx;

/* render targete resolution*/
uniform vec2 rt_resolution;

/* bounding box size */
uniform vec3 boxMin;
uniform vec3 boxMax;

/* voxel size */
uniform float voxelSize;
uniform vec3 halfVoxelSize;

/* sampling frequency */
uniform float rayStepRatio;

/* value range */
uniform vec2 valRange;

/*	texture that houses the volume data */
uniform highp sampler3D volume_tx3D;
            ]]>
        </snippet>
        <snippet name="output" type="string">
            <![CDATA[
/* output image */
layout(rgba32f, binding = 0) writeonly uniform highp image2D render_target_tx2D;
            ]]>
        </snippet>
        <snippet name="functionality" type="string">
            <![CDATA[
struct Ray {
    vec3 o;
    vec3 d;
};

bool intersectBox(Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar) {
    vec3 invR = vec3(1.0f) / r.d;
    vec3 tbot = invR * (boxmin - r.o);
    vec3 ttop = invR * (boxmax - r.o);

    // Special case for a ray lying in a bounding plane.
    if (r.d.x == 0.0f && r.o.x == boxmax.x) {
        ttop.x = -FLT_MAX;
        tbot.x = FLT_MAX;
    }
    if (r.d.y == 0.0f && r.o.y == boxmax.y) {
        ttop.y = -FLT_MAX;
        tbot.y = FLT_MAX;
    }
    if (r.d.z == 0.0f && r.o.z == boxmax.z) {
        ttop.z = -FLT_MAX;
        tbot.z = FLT_MAX;
    }

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    float largest_tmin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));
    float smallest_tmax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));

    tnear = largest_tmin;
    tfar = smallest_tmax;

    return smallest_tmax > largest_tmin;
}

float wang_hash(uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);

    return float(seed) / 4294967296.0;
}

float calculate_depth(vec3 pos) {
    vec4 clip_pos = proj_mx * view_mx * vec4(pos, 1.0f);
    
    return ((clip_pos.z / clip_pos.w) + 1.0f) / 2.0f;
}
            ]]>
        </snippet>
        <snippet name="ray_generation" type="string">
            <![CDATA[
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    // Get pixel coordinates
    vec3 gID = gl_GlobalInvocationID.xyz;

    if (gID.x >= rt_resolution.x || gID.y >= rt_resolution.y) return;

    ivec2 pixel_coords = ivec2(gID.xy);

    vec2 clip_space_pixel_coords =
        vec2((gID.x / rt_resolution.x) * 2.0f - 1.0f, (gID.y / rt_resolution.y) * 2.0f - 1.0f);

    // Generate ray
    Ray ray;
    
    // (unproject a point on the near plane and use as an origin)
    mat4 inv_view_proj_mx = inverse(proj_mx * view_mx);
    vec4 unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, -1.0f, 1.0f);
    
    ray.o = unproj.xyz / unproj.w;
    
    // (unproject a point at the same pixel, but further away from the near plane
    // to compute a ray direction in world space)
    unproj = inv_view_proj_mx * vec4(clip_space_pixel_coords, 0.0f, 1.0f);
    
    ray.d = normalize((unproj.xyz / unproj.w) - ray.o);

    // Calculate sampling frequency
    float rayStep = voxelSize * rayStepRatio;
    vec3 box_range = boxMax - boxMin;
    float max_bbox_length = max(max(box_range.x, box_range.y), box_range.z);

    // Generate a random value in [0, 1] range.
    float random = wang_hash(pixel_coords.x + pixel_coords.y * uint(rt_resolution.x));

    // Require tnear or tfar to be positive, so that we can renderer from inside the box,
    // but do not render if the box is completely behind the camera.
    float tnear, tfar;

    if (intersectBox(ray, boxMin, boxMax, tnear, tfar) && (tnear > 0.0f || tfar > 0.0f)) {
        // Compute near and far clipping distance
        const vec4 near_point = inverse(proj_mx) * vec4(0.0f, 0.0f, -1.0f, 1.0f);
        const vec4 far_point = inverse(proj_mx) * vec4(0.0f, 0.0f, 1.0f, 1.0f);

        // Initialize ray start and randomly offset it to prevent ringing artifacts
        float t = tnear >= 0.0f ? tnear : 0.0f;
        t += random * rayStep;

        // Initialize results
        vec4 result = vec4(0.0f);
            ]]>
        </snippet>
        <snippet name="ray_step" type="string">
            <![CDATA[
            vec3 pos = ray.o + t * ray.d;
            
            // Compute volume tex coordinates in [0,1] range.
            vec3 texCoords = (pos - boxMin) / (boxMax - boxMin);
            texCoords *= 1.0 - 2.0 * halfVoxelSize;
            texCoords += halfVoxelSize;
            ]]>
        </snippet>
        <snippet name="loop_end" type="string">
            <![CDATA[
            t += rayStep;
        }

        // Write results
        imageStore(render_target_tx2D, pixel_coords, result);
            ]]>
        </snippet>
        <snippet name="else" type="string">
            <![CDATA[
    } else {
        // Always write out to make sure that data from the previous frame is overwritten.
        imageStore(render_target_tx2D, pixel_coords, vec4(0.0));
            ]]>
        </snippet>
        <snippet name="end" type="string">
            <![CDATA[
    }
}
            ]]>
        </snippet>
    </namespace>

    <shader name="compute">
        <snippet type="version">430</snippet>
        <snippet name="::RaycastVolumeRenderer::common::input" />
        <snippet type="string">
            <![CDATA[
/* opacity threshold for integration */
uniform float opacityThreshold;

/* texture containing transfer function */
uniform highp sampler1D tf_tx1D;

/* texture containing a depth buffer */
uniform highp sampler2D color_tx2D;
uniform highp sampler2D depth_tx2D;
uniform int use_depth_tx;
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::output" />
        <snippet name="::RaycastVolumeRenderer::common::functionality" />
        <snippet name="::RaycastVolumeRenderer::common::ray_generation" />
        <snippet type="string">
            <![CDATA[
        while (t < tfar && result.w < opacityThreshold) {
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::ray_step" />
        <snippet type="string">
            <![CDATA[
            if (use_depth_tx != 0) {
                // Compare depth values and decide to abort
                vec2 pixel_tex_coords = vec2(gID.x / rt_resolution.x, gID.y / rt_resolution.y);
                const float input_depth = texture(depth_tx2D, pixel_tex_coords).x;
                
                const float depth = calculate_depth(pos);

                if (depth > input_depth) {
                    const vec4 color = texture(color_tx2D, pixel_tex_coords);

                    result += (1.0f - result.w) * color;

                    break;
                }
            }
            
            // Get sample
            vec4 vol_sample = texture(tf_tx1D, (texture(volume_tx3D, texCoords).x - valRange.x) / valRange.y);

            // Opacity correction.
            vol_sample.w = (1.0f - pow(1.0f - vol_sample.w, rayStepRatio));
            vol_sample.xyz *= vol_sample.w;

            result += (1.0f - result.w) * vol_sample;
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::loop_end" />
        <snippet name="::RaycastVolumeRenderer::common::else" />
        <snippet name="::RaycastVolumeRenderer::common::end" />
    </shader>

    <shader name="compute_iso">
        <snippet type="version">430</snippet>
        <snippet name="::RaycastVolumeRenderer::common::input" />
        <snippet type="string">
            <![CDATA[
/* isovalue used for isosurface reconstruction */
uniform float isoValue;
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::output" />
        <snippet type="string">
            <![CDATA[
/* output normal */
layout(r32f, binding = 1) writeonly uniform highp image2D normal_target_tx2D;

/* output depth */
layout(r32f, binding = 2) writeonly uniform highp image2D depth_target_tx2D;
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::functionality" />
        <snippet type="string">
            <![CDATA[
vec3 blinnPhong(vec3 n, vec3 l, vec3 v) {
    vec3 color = vec3(0.0);

    // ambient
    color.x = 0.1f;

    // diffuse
    float NdotL = max(0.0f, dot(n, l));
    NdotL = abs(dot(n, l));

    color.y = 0.6f * NdotL;

    // specular
    vec3 h = normalize(l + v);
    float NdotH = max(0.0f, dot(n, h));
    NdotH = abs(dot(n, h));

    color.z = 0.3f * ((10.0f + 2.0f) / (2.0f * PI)) * pow(NdotH, 10.0f);

    return color;
}
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::ray_generation" />
        <snippet type="string">
            <![CDATA[
        // Initialize output depth and normal value
        float depth = FLT_MAX;
        vec3 normal = vec3(0.0f);

        // Store value and position from previous step
        vec3 old_pos = ray.o + t * ray.d;
        float old_value = 0.0f;

        while (t < tfar) {
            ]]>
    </snippet>
    <snippet name="::RaycastVolumeRenderer::common::ray_step" />
    <snippet type="string">
        <![CDATA[
            // Get volume sample
            float vol_sample = texture(volume_tx3D, texCoords).x;

            if (vol_sample > isoValue) {
                // Compute relative position between sample positions
                const vec3 direction = pos - old_pos;
                const float distance = (isoValue - old_value) / (vol_sample - old_value);

                const vec3 surface_pos = old_pos + distance * direction;

                depth = calculate_depth(surface_pos);

                // Compute normal
                const float left = textureOffset(volume_tx3D, texCoords, ivec3(-1, 0, 0)).x;
                const float right = textureOffset(volume_tx3D, texCoords, ivec3(1, 0, 0)).x;

                const float bottom = textureOffset(volume_tx3D, texCoords, ivec3(0, -1, 0)).x;
                const float top = textureOffset(volume_tx3D, texCoords, ivec3(0, 1, 0)).x;

                const float front = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, -1)).x;
                const float back = textureOffset(volume_tx3D, texCoords, ivec3(0, 0, 1)).x;

                normal.x = (right - left) / (4.0f * halfVoxelSize.x);
                normal.y = (top - bottom) / (4.0f * halfVoxelSize.y);
                normal.z = (back - front) / (4.0f * halfVoxelSize.z);
                normal = normalize(normal);

                // Compute illumination from fixed light
                const vec3 illumination = blinnPhong(normal, normalize(-surface_pos), normalize(-surface_pos));

                const vec3 lightColor = vec3(1.0f, 1.0f, 1.0f);
                const vec3 materialColor = vec3(0.95f, 0.67f, 0.47f);

                result = vec4((illumination.x + illumination.y) * materialColor + illumination.z * lightColor, 1.0f);

                break;
            }

            // Store value and position for new "previous" step
            old_pos = pos;
            old_value = vol_sample;
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::loop_end" />
        <snippet type="string">
            <![CDATA[
        imageStore(normal_target_tx2D, pixel_coords, vec4(normal, 0.0f));
        imageStore(depth_target_tx2D, pixel_coords, vec4(depth));
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::else" />
        <snippet type="string">
            <![CDATA[
        imageStore(normal_target_tx2D, pixel_coords, vec4(0.0f));
        imageStore(depth_target_tx2D, pixel_coords, vec4(FLT_MAX));
            ]]>
        </snippet>
        <snippet name="::RaycastVolumeRenderer::common::end" />
    </shader>

    <shader name="vert">
        <snippet type="version">430</snippet>
        <snippet name="body" type="string">
            <![CDATA[
out vec2 uv_coord;

void main()
{
    const vec4 vertices[6] = vec4[6](
        vec4(-1.0, -1.0, 0.0, 0.0),
        vec4( 1.0,  1.0, 1.0, 1.0),
        vec4(-1.0,  1.0, 0.0, 1.0),
        vec4( 1.0,  1.0, 1.0, 1.0),
        vec4(-1.0, -1.0, 0.0, 0.0),
        vec4( 1.0, -1.0, 1.0, 0.0));
    
    const vec4 vertex = vertices[gl_VertexID];
    
    uv_coord = vertex.zw;
    gl_Position =  vec4(vertex.xy, -1.0, 1.0);
}
            ]]>
        </snippet>
    </shader>

    <shader name="frag">
        <snippet type="version">430</snippet>
        <snippet name="body" type="string">
            <![CDATA[
uniform sampler2D src_tx2D;
uniform sampler2D normal_tx2D;
uniform sampler2D depth_tx2D;

in vec2 uv_coord;

layout (location = 0) out vec4 frag_out;
layout (location = 1) out vec4 normal_out;

void main()
{
    frag_out = texture(src_tx2D, uv_coord);
    normal_out = texture(normal_tx2D, uv_coord);
    
    gl_FragDepth = texture(depth_tx2D, uv_coord).x;
}
            ]]>
        </snippet>
    </shader>

</btf>
