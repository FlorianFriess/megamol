<?xml version="1.0" encoding="utf-8"?>
<btf namespace="splom" type="MegaMolGLSLShader" version="1.0">
  <shader name="vert">
    <snippet type="version">140</snippet>
    <snippet type="string">
      <![CDATA[
#extension GL_ARB_shader_storage_buffer_object : require
#extension GL_EXT_gpu_shader4 : require

#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif


struct SphereParams {
    float posX; float posY; float color; uint desc;
    //uint desc; float color; float posY; float posX;
};

layout(std430, packed, binding = 2) buffer shader_data {
    SphereParams theBuffer[];
};



uniform float inRad;



uniform vec4 viewAttr;

uniform float scaling;
uniform float alphaScaling;
uniform float zNear;

#ifndef CALC_CAM_SYS
uniform vec3 camIn;
uniform vec3 camUp;
uniform vec3 camRight;
uniform mat4 modelViewProjection;
uniform mat4 modelViewInverse;
uniform mat4 modelView;
#else
uniform mat4 modelViewProjection;
uniform mat4 modelViewInverse;
uniform mat4 modelView;
#endif // CALC_CAM_SYS

// clipping plane attributes
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform int instanceOffset;
uniform int attenuateSubpixel;

uniform vec4 inConsts1;
in float colIdx;
uniform sampler1D colTab;

uniform uint pointIdx;
uniform int pik;
uniform uint idxOffset;

out vec4 objPos;
out vec4 camPos;
//varying vec4 lightPos;
out float squarRad;
out float rad;
out float effectiveDiameter;

#ifdef DEFERRED_SHADING
out float pointSize;
#endif

#ifdef RETICLE
out vec2 centerFragment;
#endif // RETICLE

out vec4 vsColor;

#define CONSTRAD inConsts1.x
#define MIN_COLV inConsts1.y
#define MAX_COLV inConsts1.z
#define COLTAB_SIZE inConsts1.w


void main(void) {
    float theColIdx;
    vec4 theColor;
    vec4 inPos;

    inPos = vec4(theBuffer[gl_VertexID + instanceOffset].posX,
        theBuffer[gl_VertexID + instanceOffset].posY,
        0.0f, 1.0f);

    rad = inConsts1.x;

    // remove the sphere radius from the w coordinates to the rad varyings
    //vec4 inPos = gl_Vertex;
    //rad = (CONSTRAD < -0.5) ? inPos.w : CONSTRAD;
    //inPos.w = 1.0;
    //inPos = vec4(0.0, 0.0, 0.0, 1.0);
    //rad = 1.0;

    // float cid = MAX_COLV - MIN_COLV;
    // if (cid < 0.000001) {
    //     vsColor = theColor;
    // } else {
    //     cid = (theColIdx - MIN_COLV) / cid;
    //     cid = clamp(cid, 0.0, 1.0);
        
    //     cid *= (1.0 - 1.0 / COLTAB_SIZE);
    //     cid += 0.5 / COLTAB_SIZE;
        
    //     vsColor = texture(colTab, cid);
    // }

if (inConsts1.w == 0) {
    vsColor = vec4(1.0f);
}else{
    // lookup in texture
    float cid = inConsts1.z - inConsts1.y;
     cid = (theBuffer[gl_VertexID + instanceOffset].color - inConsts1.y) / cid;
     cid = clamp(cid, 0.0, 1.0);
        
     cid *= (1.0 - 1.0 / inConsts1.w);
     cid += 0.5 / inConsts1.w;
        
     vsColor = texture(colTab, cid);
}


    rad *= scaling;

    squarRad = rad * rad;



    // object pivot point in object space    
    objPos = inPos; // no w-div needed, because w is 1.0 (Because I know)

    // calculate cam position
    camPos = modelViewInverse[3]; // (C) by Christoph
    camPos.xyz -= objPos.xyz; // cam pos to glyph space

    // calculate light position in glyph space
    //lightPos = modelViewInverse * gl_LightSource[0].position;



    // Sphere-Touch-Plane-Approachâ„¢
    vec2 winHalf = 2.0 / viewAttr.zw; // window size

    vec2 d, p, q, h, dd;

    // get camera orthonormal coordinate system
    vec4 tmp;

#ifdef CALC_CAM_SYS
    // camera coordinate system in object space
    tmp = modelViewInverse[3] + modelViewInverse[2];
    vec3 camIn = normalize(tmp.xyz);
    tmp = modelViewInverse[3] + modelViewInverse[1];
    vec3 camUp = tmp.xyz;
    vec3 camRight = normalize(cross(camIn, camUp));
    camUp = cross(camIn, camRight);
#endif // CALC_CAM_SYS

    vec2 mins, maxs;
    vec3 testPos;
    vec4 projPos;

    // projected camera vector
    vec3 c2 = vec3(dot(camPos.xyz, camRight), dot(camPos.xyz, camUp), dot(camPos.xyz, camIn));

    vec3 cpj1 = camIn * c2.z + camRight * c2.x;
    vec3 cpm1 = camIn * c2.x - camRight * c2.z;

    vec3 cpj2 = camIn * c2.z + camUp * c2.y;
    vec3 cpm2 = camIn * c2.y - camUp * c2.z;
    
    d.x = length(cpj1);
    d.y = length(cpj2);

    dd = vec2(1.0) / d;

    p = squarRad * dd;
    q = d - p;
    h = sqrt(p * q);
    //h = vec2(0.0);
    
    p *= dd;
    h *= dd;

    cpj1 *= p.x;
    cpm1 *= h.x;
    cpj2 *= p.y;
    cpm2 *= h.y;

    // TODO: rewrite only using four projections, additions in homogenous coordinates and delayed perspective divisions.
    testPos = objPos.xyz + cpj1 + cpm1;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    //projPos /= projPos.w;
    mins = projPos.xy;
    maxs = projPos.xy;

    testPos -= 2.0 * cpm1;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    //projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos = objPos.xyz + cpj2 + cpm2;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    //projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);

    testPos -= 2.0 * cpm2;
    projPos = modelViewProjection * vec4(testPos, 1.0);
    //projPos /= projPos.w;
    mins = min(mins, projPos.xy);
    maxs = max(maxs, projPos.xy);
    //gl_Position = vec4((mins + maxs) * 0.5, 0.0, (od > clipDat.w) ? 0.0 : 1.0);
    //gl_Position = vec4((mins + maxs) * 0.5, 0.0, 1.0);
    gl_Position = modelViewProjection*objPos;
    maxs = (maxs - mins) * 0.5 * winHalf;
    //gl_PointSize = max(maxs.x, maxs.y) + 0.5;
    gl_PointSize = rad*(modelViewProjection[0][0]);


    if (pik==1) {
    if (theBuffer[gl_VertexID + instanceOffset].desc == pointIdx) {
        //vsColor = vec4(1.0, 0.0, 0.0f, 1.0f);
        //gl_PointSize *= 100;
        gl_PointSize *= 4;
    } else {
        //vsColor = vec4(0.0, 0.0, 0.0f, 0.0f);
        //gl_PointSize = 0;
        vsColor.a = 0.25;
    }
}

    if (attenuateSubpixel == 1) {
        effectiveDiameter = gl_PointSize;
    } else {
        effectiveDiameter = 1.0;
    }

    //vec4 projPos = gl_ModelViewProjectionMatrix * vec4(objPos.xyz, 1.0);
    //projPos /= projPos.w;
    //gl_Position = projPos;
    //float camDist = sqrt(dot(camPos.xyz, camPos.xyz));
    //gl_PointSize = max((rad / camDist) * zNear, 1.0);

}
      ]]>
    </snippet>
  </shader>

  <shader name="frag">
    <snippet type="version">140</snippet>
    <snippet type="string">
      <![CDATA[
#define CLIP
#define DEPTH
#define SMALL_SPRITE_LIGHTING
//#define CALC_CAM_SYS

#ifdef DEBUG
#undef CLIP
#define RETICLE
#define AXISHINTS
#endif // DEBUG

//#define BULLSHIT

#ifndef FLACH
#define FLACH
#endif


// 2D gaussian distribution.
// Source: http://mathworld.wolfram.com/GaussianFunction.html
float gauss2(vec2 p)
{
    float sigma = 2.0f;
 return exp(-(0.5 * dot(p, p)))/(sigma*2.506628274631000502415765284811);
}


// TODO: Implementation is wrong! Does positional Lighting instead of directional lighting!

// ray:      the eye to fragment ray vector
// normal:   the normal of this fragment
// lightPos: the position of the light source
// color:    the base material color
vec3 LocalLighting(const in vec3 ray, const in vec3 normal, const in vec3 lightPos, const in vec3 color) {
    // TODO: rewrite!
    vec3 lightDir = normalize(lightPos);

    vec4 lightparams = vec4(0.2, 0.8, 0.4, 10.0);
#define LIGHT_AMBIENT lightparams.x
#define LIGHT_DIFFUSE lightparams.y
#define LIGHT_SPECULAR lightparams.z
#define LIGHT_EXPONENT lightparams.w
    float nDOTl = dot(normal, lightDir);

    vec3 r = normalize(2.0 * vec3(nDOTl) * normal - lightDir);
    return LIGHT_AMBIENT * color 
        + LIGHT_DIFFUSE * color * max(nDOTl, 0.0) 
        + LIGHT_SPECULAR * vec3(pow(max(dot(r, -ray), 0.0), LIGHT_EXPONENT));
}

#ifdef BACKSIDE_ENABLED
uniform float hitsideFlag;
#endif // BACKSIDE_ENABLED
//#define DISCARD_COLOR_MARKER

// clipping plane attributes
uniform vec4 clipDat;
uniform vec4 clipCol;
uniform float alphaScaling;

uniform vec4 viewAttr;

FLACH in vec4 objPos;
FLACH in vec4 camPos;
//FLACH in vec4 lightPos;
FLACH in float squarRad;
FLACH in float rad;
FLACH in float effectiveDiameter;

#ifdef RETICLE
FLACH in vec2 centerFragment;
#endif // RETICLE

in vec4 vsColor;
out vec4 outColor;

void main(void) {

    //gl_FragColor = vec4((gl_PointCoord.xy - vec2(0.5)) * vec2(2.0), 0.0, 1.0);
    //gl_FragColor = vec4(gl_PointCoord.xy, 0.5, 1.0);
    //gl_FragColor = vsColor;
    vec2 dist = gl_PointCoord.xy - vec2(0.5);
    //float d = sqrt(dot(dist, dist));
    //float alpha = 0.5-d;
    float alpha = gauss2(dist*6);
    alpha *= effectiveDiameter * effectiveDiameter;
    alpha *= alphaScaling;
    //alpha = 0.5;
#if 1
    // blend against white!
    outColor = vec4(vsColor.rgb, vsColor.a*alpha);

    //outColor = vec4(vec3(gl_PointCoord.xy, 0), alpha);
#else
    outColor = vec4(vsColor.rgb * alpha, alpha);
#endif
    //gl_FragColor = vec4(vsColor.rgb, 1.0);
}
      ]]>
    </snippet>
  </shader>
</btf>
